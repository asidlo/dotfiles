"==============================================================================
" Author:  Andrew Sidlo
" Updated: 2020/06/24 23:23:12
"==============================================================================
" VARIABLES {{{
"==============================================================================
let g:is_win = has('win32') || has('win64')
let g:is_linux = has('unix') && !has('macunix')
let g:is_nvim = has('nvim')
let g:is_gui = has('gui_running')

" Vim on windows doesn't have uname so results in error message even though we
" already know its not macos
if !g:is_nvim && g:is_win
  let g:is_mac = 0
else
  " Has some issues with vim detecting macunix/mac
  let g:is_mac = has('macunix') || substitute(system('uname -s'), '\n', '', '') == 'Darwin'
endif

" Vim directory where all settings, plugins, syntax, etc stored
" Note: expand vs glob = glob will return empty if file doesnt exist
" also, expand has a list of special variables (see :h expand)
if g:is_win
  let g:vim_dir = expand('~/vimfiles')
else
  let g:vim_dir = expand('~/.vim')
endif

if g:is_mac
  let g:ctags_exe = '/usr/local/opt/universal-ctags/bin/ctags'
else
  let g:ctags_exe = 'ctags'
endif

" Disable python2, ruby, and node providers
let g:loaded_python_provider = 0
let g:loaded_ruby_provider = 0
let g:loaded_perl_provider = 0
let g:loaded_node_provider = 0

let s:undo_dir = g:vim_dir . '/undo'
if empty(glob(s:undo_dir))
  throw "Undo dir does not exist, please create it to ensure change history: " . s:undo_dir
endif

if !executable('rg')
  throw 'Ripgrep executable not found! Install and add to Path to perform project searching'
endif

" if !executable('ctags')
"   throw 'ctags is required for tagbar, please install ctags and add to PATH'
" endif

if g:is_mac && !executable('fzf')
  throw 'fzf is required for fuzzy searching, please install fzf and add to PATH'
endif

" if !executable('ctags')
"   throw 'ctags is required for generating tags, please install ctags and add to PATH'
" endif
"
"
" if !executable('gtags')
"   " https://code.google.com/archive/p/cscope-win32/downloads Or brew install
"   " echoerr 'cscope executable not found! Install cscope and add to Path for static project analysis'
"   throw 'gtags executable not found! Install gtags via gnu global package and add to Path for static project analysis'
" endif

" Path to Python 3 interpreter (must be an absolute path), make startup
" faster. See https://neovim.io/doc/user/provider.html.
if executable('python') || executable('python3')
  if g:is_win
    let g:python3_host_prog=substitute(exepath('python'), '.exe$', '', 'g')
  elseif g:is_linux || g:is_mac
    let g:python3_host_prog=exepath('python3')
  endif
else
  throw 'Python 3 executable not found! You must install Python 3 and set its PATH correctly!'
endif

if !executable('go')
  throw 'Go needs to be installed in order to run the vim-go plugin'
endif

if !exists('$GOPATH')
  throw 'Please also set go env vars [GOPATH, GOROOT, GOBIN]'
endif

" if !executable('yarn')
"   throw 'Yarn is required for installing coc.nvim'
" endif

" }}}
"==============================================================================
" PLUGIN MANAGER {{{
"==============================================================================
" Automatically download the plug.vim plugin manager vimscript
" Run :PlugInstall to install all plugins
if !g:is_win
  if empty(glob(g:vim_dir . '/autoload/plug.vim'))
    silent execute '!curl -fLo ' . expand(g:vim_dir . '/autoload/plug.vim') . ' --create-dirs ' .
      \ 'https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
    autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
  endif
else
  if empty(glob(g:vim_dir . '/autoload/plug.vim'))
    let g:vim_plug_uri = 'https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
    let g:vim_plug_powershell_download_cmd = 'Invoke-WebRequest -Uri "' . g:vim_plug_uri . '" -OutFile "' . expand(g:vim_dir . '/autoload/plug.vim') . '"'
    silent execute '!powershell -command New-Item -ItemType Directory -Path "' . expand(g:vim_dir . '/autoload') . '"'
    silent execute '!powershell -command ' . g:vim_plug_powershell_download_cmd
    autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
  endif
endif

call plug#begin(expand(g:vim_dir . '/plugged'))

" Colorschemes
Plug 'morhetz/gruvbox'
Plug 'dracula/vim', { 'as': 'dracula' }
Plug 'reedes/vim-colors-pencil'

" Tabular must come before markdown
Plug 'godlygeek/tabular'
if !g:is_win
  Plug 'iamcco/markdown-preview.nvim', { 'do': { -> mkdp#util#install() } }
endif
Plug 'plasticboy/vim-markdown'

" Golang plugins
" Need to load before vim-polyglot in order to avoid getting errors like
" Unknown function: go#config#GoplsMatcher
" See: https://github.com/fatih/vim-go/issues/2272
" See: https://github.com/fatih/vim-go/issues/2262
Plug 'fatih/vim-go', { 'do': ':GoUpdateBinaries' }
Plug 'AndrewRadev/splitjoin.vim'

" if g:is_win
"   Plug 'autozimu/LanguageClient-neovim', {
"       \ 'branch': 'next',
"       \ 'do': 'powershell -executionpolicy bypass -File install.ps1',
"       \ }
" else
"   Plug 'autozimu/LanguageClient-neovim', {
"       \ 'branch': 'next',
"       \ 'do': 'bash install.sh',
"       \ }
" endif

" Plug 'prabirshrestha/vim-lsp'
" Plug 'neovim/nvim-lsp'
Plug 'neoclide/coc.nvim', {'branch': 'release'}

Plug 'Shougo/echodoc.vim'

Plug 'tiagofumo/vim-nerdtree-syntax-highlight'
Plug 'scrooloose/nerdtree'
Plug 'airblade/vim-gitgutter'
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
Plug 'wincent/ferret'
Plug 'airblade/vim-rooter'
Plug 'ryanoasis/vim-devicons'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-unimpaired'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-dispatch'
Plug 'tpope/vim-eunuch'
Plug 'rhysd/git-messenger.vim'
Plug 'jiangmiao/auto-pairs'

" Can be used to change case of word.
" Ex: gsciw (changeToCamelCase), gs_iw (snake_case), gs-iw (kabob-case)
Plug 'arthurxavierx/vim-caser'

" Uses 'gr' to replace current selection with specified register contents
" Ex: "ayiw (copies inner word to register a) -> "agriw (replaces inner word
"     with content from register 'a')
Plug 'vim-scripts/ReplaceWithRegister'

" Targets indents
" Ex: gcii (toggles comment for all adjacent inner indented lines)
Plug 'michaeljsmith/vim-indent-object'
Plug 'kana/vim-textobj-user'
Plug 'kana/vim-textobj-function'

" Completion, highlighting, and linting
Plug 'sheerun/vim-polyglot'

" Symbol / Tag Plugins
Plug 'majutsushi/tagbar'
Plug 'ludovicchabant/vim-gutentags'

" Snippets
" Plug 'SirVer/ultisnips'
Plug 'honza/vim-snippets'
Plug 'segeljakt/vim-silicon'

" Fuzzy searching (will install if not already in path)
if g:is_mac
  Plug '/usr/local/opt/fzf'
else
  Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
endif
Plug 'junegunn/fzf.vim'

" Follow symlinks for git etc.
Plug 'moll/vim-bbye' " optional dependency
Plug 'aymericbeaumet/vim-symlink'

call plug#end()

" }}}
"==============================================================================
" SETTINGS {{{
"==============================================================================
let mapleader=","

syntax enable

" Favorite dark colors
let g:is_colo_dracula = 1
let g:is_colo_gruvbox = 0

" Favorite light colors
let g:is_colo_pencil = 0

try
  if g:is_colo_dracula
    colorscheme dracula
    set background=dark
  elseif g:is_colo_gruvbox
    colorscheme gruvbox
    set background=dark
  elseif g:is_colo_pencil
    colorscheme pencil
    set background=light
  endif
catch
  colorscheme desert
endtry

set t_Co=256
set termguicolors

hi Search gui=underline term=underline cterm=underline guibg=NONE
hi SpellBad gui=undercurl

if g:is_colo_dracula
  " Makes highlighting not an eyesore
  let g:dracula_inverse = 0

  " dracula specific highlighting
  hi Search guibg=NONE guifg=Yellow
endif

if g:is_gui
  " No toolbars, menu, or scrollbars in the GUI
  set guifont=MesloLGM\ Nerd\ Font\ Mono:h12
  set guioptions-=m " no menu
  set guioptions-=T " no toolbar
  set guioptions-=l
  set guioptions-=L
  set guioptions-=r " no scrollbar
  set guioptions-=R
endif

" See vulnerability:
" https://cithub.com/numirias/security/blob/master/doc/2019-06-04_ace-vim-neovim.md
set modelines=0
set nomodeline

" You can bind contents of the visual selection to system primary buffer
" (* register in vim, usually referred as «mouse» buffer) by using
if g:is_nvim
  vnoremap <LeftRelease> "*ygv
  set clipboard=unnamed
elseif g:is_mac
  set clipboard^=autoselect
else
  set clipboard=unnamed
endif

" TIP: use <C-R>* to paste clipboard content while in insert mode: https://stackoverflow.com/questions/2861627/paste-in-insert-mode
" Unset paste on InsertLeave.
autocmd InsertLeave * silent! set nopaste

" Dont insert first suggestion from autocompletions (omnicomplete)
" https://vim.fandom.com/wiki/Make_Vim_completion_popup_menu_work_just_like_in_an_IDE
set completeopt=longest,menuone
set omnifunc=syntaxcomplete#Complete

" Enable mouse support for specific modes
set mouse=a

"Enable filetype plugins
filetype plugin on
filetype indent on

" Disable autofolding
set nofoldenable

" Save local marks up to 100 files ('100) and global marks (f1)
" Remove all marks for buffer :delm!
" Remove all global marks :delm A-Z0-9
set viminfo='100,f1

" Add line numbers
set number

" Turn on relative number
set relativenumber

set cursorline

" You will have bad experience for diagnostic messages when it's default 4000.
set updatetime=100

" don't give |ins-completion-menu| messages.
set shortmess+=c

" always show signcolumns
set signcolumn=yes

" Disable line wrapping
set nowrap

" Add 80, 120 line columns
" set colorcolumn=80,120

"Always show current position
set ruler

" Height of the command bar
set cmdheight=2

" Hide mode indicator in command bar, since its covered via lightline
set noshowmode

" Add a bit extra margin to the left
set foldcolumn=0

" Don't redraw while executing macros (good performance config)
set lazyredraw

" Show matching brackets when text indicator is over them
set showmatch

" How many tenths of a second to blink when matching brackets
set matchtime=2

" Always show the status line
set laststatus=2

" No annoying sound on errors
set noerrorbells
set novisualbell
set belloff=all
set t_vb=
set timeoutlen=500

" Set utf8 as standard encoding and en_US as the standard language
set encoding=utf8

" Use Unix as the standard file type
set fileformats=unix,dos,mac

" A buffer becomes hidden when it is abandoned
set hid

"New splits below, not above
set splitbelow

"New splits on the right, not left
set splitright

" Make merging lines smarter when using <shift-j>
if v:version > 703 || v:version == 703 && has('patch541')
  set formatoptions+=j
endif

" Set 7 lines to the cursor - when moving vertically using j/k
set scrolloff=0

" Set to auto read when a file is changed from the outside
set autoread

" Automatically saves a file when calling :make, such as is done
" in go commands and when exiting vim
set autowriteall

" Turn backup off, since most stuff is in SVN, git et.c anyway...
set nobackup
set nowritebackup
set noswapfile

" Linebreak on 500 characters if set wrap
set linebreak
set textwidth=119
set nowrap

" How to represent non-printable characters
" In general, don't want tabs, so have them show up as special characters
set listchars=tab:>-,trail:_,extends:>,precedes:<,nbsp:~
set showbreak=\\ "
setlocal nolist "turn chars off by default, can be toggled via yol

" Configure backspace so it acts as it should act
set backspace=eol,start,indent
set whichwrap+=<,>,h,l

" For regular expressions turn magic on
set magic

" Ignore case when searching
set ignorecase

" When searching try to be smart about cases
set smartcase

" Dont Highlight search results, can be toggled with yoh | [oh
set nohlsearch

" Makes search act like search in modern browsers
set incsearch

" Use spaces instead of tabs
set expandtab

" Be smart when using tabs ;)
set smarttab

" 1 tab == 4 spaces (tabstop)
set shiftwidth=4
set tabstop=4

set autoindent
set smartindent

" Sets how many lines of history VIM has to remember
set history=500

" Disable the netrw history file which is otherwise added to ~/.vim/.netrwhist
let g:netrw_dirhistmax = 0

" This enables us to undo files even if you exit Vim.
" Note: this dir needs to be made prior to working
let &undodir = s:undo_dir
set undofile

" Turn on the Wild menu
" https://stackoverflow.com/questions/9511253/how-to-effectively-use-vim-wildmenu
set wildmenu
set wildmode=longest:full,full

" Ignore compiled files
set wildignore=*.o,*~,*.pyc,*.class
set wildignore+=*/.git/*,*/.hg/*,*/.svn/*,*/.DS_Store

" use both cscope and ctag for 'ctrl-]', ':ta', and 'vim -t'
set cscopetag

" set if using gtags instead of cscope for generating db
set cscopeprg=gtags-cscope

" check cscope for definition of a symbol before checking ctags: set to 1
" if you want the reverse search order.
set cscopetagorder=0

" show msg when any other cscope db added
set cscopeverbose

" add results (of find usages and references) to quickfix list instead of location list
set cscopequickfix=c-,t-,e-

"}}}
"==============================================================================
" MAPPINGS {{{
"==============================================================================
" Visual linewise up and down by default (and use gj gk to go quicker)
" Move cusor by display lines when wrapping
noremap <up> gk
noremap <down> gj
noremap j gj
noremap k gk

nnoremap <M-j> :m .+1<CR>==
nnoremap <M-k> :m .-2<CR>==
inoremap <M-j> <Esc>:m .+1<CR>==gi
inoremap <M-k> <Esc>:m .-2<CR>==gi
vnoremap <M-j> :m '>+1<CR>gv=gv
vnoremap <M-k> :m '<-2<CR>gv=gv

if g:is_nvim
  tnoremap <C-W> <C-\><C-n><C-W>
  if g:is_win
    nnoremap <leader>tv :vsplit term://powershell<cr>
    nnoremap <leader>ts :split term://powershell<cr>
    nnoremap <leader>tt :e term://powershell<cr>
  else
    nnoremap <leader>tv :vsplit term://zsh<cr>
    nnoremap <leader>ts :split term://zsh<cr>
    nnoremap <leader>tt :e term://zsh<cr>
  endif
  autocmd BufEnter term://* startinsert!
endif

" Prevent selecting and pasting from overwriting what you originally copied.
xnoremap p pgvy

" Keep cursor at the bottom of the visual selection after you yank it.
vmap y ygv<esc>

" While in visual mode(double click), control-c copies to clipboard
vmap <C-C> y

" search will center on the line it's found in.
nnoremap n nzzzv
nnoremap N Nzzzv

" Act like D and C
" yank from current position till end of line
nnoremap Y y$

" Edit global todo.md
let g:notes_dir = g:vim_dir . '/notes'
if (empty(glob(g:notes_dir)))
  call mkdir(g:notes_dir)
  exec '!git clone git@github.com:asidlo/notes.git ' . g:notes_dir
endif

" TODO - replace with sessions
nnoremap <expr> <leader>td ':e ' . g:notes_dir . '/README.md<CR>'

" Reload vimrc
" nnoremap confr :source $MYVIMRC<cr>

" Edit vimrc
" Note: '<expr>' is required to using variable in mapping
" See: h: map-expression
" nnoremap <expr> confe ':e ' . g:rc_file . '<cr>'
" nnoremap confe :e $MYVIMRC<cr>

" Switch to last buffer --> use CTRL-^ instead
nnoremap <leader>e :e#<cr>

" use `u` to undo, use `U` to redo, mind = blown
nnoremap U <c-r>

" Return to last edit position when opening files (You want this!)
au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif

"Go back to visual mode after indenting
vnoremap < <gv
vnoremap > >gv

" Remove current highlighting
nnoremap <leader><cr> :noh<cr>

" Search for current word but dont jump to next result
nnoremap * :let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>

" Prints number of hits and num lines where hits found for last search
command! SearchHits %s///gn

" replace vim's built-in visual * and # behavior
xnoremap * :<C-u>call <SID>visual_star_search('/')<CR>/<C-R>=@/<CR><CR>
xnoremap # :<C-u>call <SID>visual_star_search('?')<CR>?<C-R>=@/<CR><CR>

" makes * and # work on visual mode too.  global function so user mappings can call it.
function! s:visual_star_search(cmdtype,...)
  let temp = @"
  normal! gvy
  let @/ = substitute(@", '\n', '\\n', 'g')
  let @/ = substitute(@/, '\[', '\\[', 'g')
  let @/ = substitute(@/, '\~', '\\~', 'g')
  let @" = temp
endfunction

"<F20> == <S-F8>
" Press * to search for the term under the cursor or a visual selection and
" then press a key below to replace all instances of it in the current file.
" c = confirm each
nnoremap <F20> :%s///gc<left><left><left>

" The same as above but instead of acting on the whole file it will be
" restricted to the previously visually selected range. You can do that by
" pressing *, visually selecting the range you want it to apply to and then
" press a key below to replace all instances of it in the current selection.
xnoremap <F20> :s///gc<left><left><left>

" Map <Space> to / (search)
nmap <space> /
nmap <c-space> ?

" Vim like keys for the command line
cnoremap <c-h> <home>
cnoremap <c-l> <end>
cnoremap <c-k> <c-u>
cnoremap <c-p> <up>
cnoremap <c-n> <down>

" }}}
"==============================================================================
" PLUGINS {{{
"==============================================================================
" NVIM-LSP {{{
"==============================================================================
" lua << EOF
"   local nvim_lsp = require'nvim_lsp'
"   nvim_lsp.rls.setup{}
"   nvim_lsp.vimls.setup{}
" EOF

" nnoremap <silent> gd    <cmd>lua vim.lsp.buf.declaration()<CR>
" nnoremap <silent> <c-]> <cmd>lua vim.lsp.buf.definition()<CR>
" nnoremap <silent> K     <cmd>lua vim.lsp.buf.hover()<CR>
" nnoremap <silent> gD    <cmd>lua vim.lsp.buf.implementation()<CR>
" nnoremap <silent> <c-k> <cmd>lua vim.lsp.buf.signature_help()<CR>
" nnoremap <silent> 1gD   <cmd>lua vim.lsp.buf.type_definition()<CR>
" nnoremap <silent> gr    <cmd>lua vim.lsp.buf.references()<CR>
" nnoremap <silent> g0    <cmd>lua vim.lsp.buf.document_symbol()<CR>
" nnoremap <silent> gW    <cmd>lua vim.lsp.buf.workspace_symbol()<CR>

" autocmd Filetype vim,rust setlocal omnifunc=v:lua.vim.lsp.omnifunc

" }}}
"==============================================================================
" VIM-LSP {{{
"==============================================================================

" Notes: I love the fact that it is pure vimscript and utilizes native
" vim functions / idioms. However, there is a lot of work to be done.
" It needs the ability to navigate to java classes ie jdk files / jar files
" It needs the ability to change the LspDocumentSymbols output to location list
" since this makes more sense than quickfix list. It should have some way to
" put all of the diagnostics into a quickfix list from the entire project and
" not just from a single file. Also should handle the lsp output from the eclipse
" debug settings


" let g:jdtls_script = glob(g:vim_dir . '/java/bin/jdtls.sh')
" if executable('java') && filereadable(g:jdtls_script)
"   autocmd User lsp_setup call lsp#register_server({
"     \ 'name': 'eclipse.jdt.ls',
"     \ 'cmd': {server_info->[&shell, &shellcmdflag, g:jdtls_script]},
"     \ 'whitelist': ['java'],
"     \ })
" endif

" function! s:on_lsp_buffer_enabled() abort
"   setlocal omnifunc=lsp#complete
"   setlocal signcolumn=yes
"   if exists('+tagfunc') | setlocal tagfunc=lsp#tagfunc | endif
"   set foldmethod=expr
"     \ foldexpr=lsp#ui#vim#folding#foldexpr()
"     \ foldtext=lsp#ui#vim#folding#foldtext()

"   set formatexpr=lsp#ui#vim#document_format_sync()

"   nmap <buffer> gd <plug>(lsp-definition)
"   nmap <buffer> K <plug>(lsp-hover)
"   nmap <buffer> <f2> <plug>(lsp-rename)
" endfunction

" augroup lsp_install
"   au!
"   autocmd User lsp_buffer_enabled call s:on_lsp_buffer_enabled()
" augroup END

" " Opens preview windows as normal windows
" let g:lsp_preview_float = 0

" " Preview remains open and waits for an explicit call
" let g:lsp_preview_autoclose = 0

" let g:lsp_log_file = expand(g:vim_dir . '/vim-lsp.log')
" highlight LspErrorHighlight term=underline cterm=underline gui=underline
" highlight LspWarningHighlight term=underline cterm=underline gui=underline
" highlight LspInformationHighlight term=underline cterm=underline gui=underline
" highlight LspHintHighlight term=underline cterm=underline gui=underline
" highlight link LspWarningVirtual DraculaOrange
" highlight link LspWarningText DraculaOrange

" }}}
"==============================================================================
" ECHODOC {{{
"==============================================================================
let g:echodoc#enable_at_startup = 1
let g:echodoc#type = 'signature'

" }}}
"==============================================================================
" COC {{{
"==============================================================================
let g:coc_global_extensions = [ 'coc-json', 'coc-python', 'coc-vimlsp', 'coc-java', 'coc-snippets', 'coc-rls']
let g:coc_data_home = expand(g:vim_dir . '/coc')
let g:coc_config_home = g:coc_data_home

highlight link CocHighlightText CocUnderline

augroup coc_lsp
  autocmd!
  if exists('*CocActionAsync')
    " Highlight the symbol and its references when holding the cursor.
    autocmd CursorHold * silent call CocActionAsync('highlight')
  endif

  autocmd FileType java setlocal formatexpr=CocAction('formatSelected')
  autocmd FileType rust setlocal formatexpr=CocAction('format')

  xmap ga <Plug>(coc-codeaction-selected)
  nmap ga <Plug>(coc-codeaction-selected)

  " <S-F6> == <F18>
  autocmd FileType java,rust,vim nmap <buffer> <F18> <Plug>(coc-rename)
  autocmd FileType java,rust,vim nmap <buffer><silent> <F6> <Plug>(coc-references)

  nnoremap <silent><nowait> ]c :<C-u>CocNext<CR>
  nnoremap <silent><nowait> [c :<C-u>CocPrev<CR>

  inoremap <silent><expr> <c-space> coc#refresh()
  imap <C-j> <Plug>(coc-snippets-expand-jump)

  " Use `:CocDiagnostics` to get all diagnostics of current buffer in location list.
  nmap <silent> [d <Plug>(coc-diagnostic-prev)
  nmap <silent> ]d <Plug>(coc-diagnostic-next)

  autocmd FileType java,rust,vim nmap <buffer><silent> <C-]> <Plug>(coc-definition)
  autocmd FileType rust nmap <buffer><silent> gd <Plug>(coc-declaration)
  autocmd FileType java,rust nmap <buffer><silent> gD <Plug>(coc-implementation)
  autocmd FileType rust nmap <buffer><silent> 1gD <Plug>(coc-type-definition)
  autocmd FileType java,rust,vim nnoremap <buffer><silent><nowait> g0 :<C-u>CocList outline<CR>
  autocmd FileType java,rust nnoremap <buffer><silent> K :call CocAction('doHover')<CR>

  " enter to select completion
  inoremap <expr> <cr> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"

  " use tab for easy completion navigation
  inoremap <expr> <Tab> pumvisible() ? "\<C-n>" : "\<Tab>"
  inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
  inoremap <silent><expr> <cr> pumvisible() ? coc#_select_confirm() : "\<C-g>u\<CR>"
augroup end

nmap <leader>l :call CocAction('format')
nmap <leader>; :call CocAction('runCommand', 'editor.action.organizeImport')

command! -nargs=0 Fmt :call CocAction('format')
command! -nargs=? Fold :call CocAction('fold', <f-args>)
command! -nargs=0 OrganizeImports :call CocAction('runCommand', 'editor.action.organizeImport')
command! -nargs=0 CocStatus echo coc#status()

abbreviate CC CocConfig
abbreviate CCL CocLocalConfig
abbreviate CI CocInfo
abbreviate CD CocDiagnostics
abbreviate CF CocFix
abbreviate CL CocList
abbreviate CU CocUpdate
abbreviate CX CocCommand
abbreviate CA CocAction
abbreviate CLR CocListResume
abbreviate CLO CocList outline
abbreviate CLD CocList diagnostics
abbreviate CLC CocList commands
abbreviate CLS CocList snippets
abbreviate CS CocStatus

" }}}
"==============================================================================
" LANGUAGECLIENT {{{
"==============================================================================
  " \ 'java': ['/Users/asidlo/.local/share/vim-lsp-settings/servers/eclipse-jdt-ls/eclipse-jdt-ls']
" if g:is_win
"   let g:jdtls_script = expand(g:vim_dir.'/java/bin/jdtls.ps1')
" else
"   let g:jdtls_script = expand(g:vim_dir.'/java/bin/jdtls.sh')
" endif

" if g:is_win
"   let g:LanguageClient_serverCommands = {
"     \ 'rust': ['rustup', 'run', 'stable', 'rls'],
"     \ 'python': ['/usr/local/bin/pyls'],
"     \ 'java': ['powershell', '-NoExit', '-File', g:jdtls_script]
"     \ }
" else
"   let g:LanguageClient_serverCommands = {
"     \ 'rust': ['rustup', 'run', 'stable', 'rls'],
"     \ 'python': ['/usr/local/bin/pyls'],
"     \ 'java': [g:jdtls_script]
"     \ }
" endif

" function LC_maps()
"   if has_key(g:LanguageClient_serverCommands, &filetype)
"     nnoremap <buffer> <silent> K :call LanguageClient#textDocument_hover()<cr>
"     nnoremap <buffer> <silent> gd :call LanguageClient#textDocument_definition()<CR>
"     nnoremap <buffer> <silent> <F2> :call LanguageClient#textDocument_rename()<CR>
"     nnoremap <buffer> <silent> <leader>o :call LanguageClient#textDocument_documentSymbol()<CR>
"     setlocal formatexpr=LanguageClient#textDocument_rangeFormatting_sync()
"   endif
" endfunction

" autocmd FileType * call LC_maps()

" let g:LanguageClient_loggingFile = expand(g:vim_dir . '/LanguageClient.log')
" let g:LanguageClient_loggingLevel = 'DEBUG'

" command! Symbol call <SID>symbol_tag_switch()

" function! s:symbol_tag_switch() abort
"   if has_key(g:LanguageClient_serverCommands, &filetype)
"     call LanguageClient#textDocument_documentSymbol()
"   else
"     call s:btags()
"   endif
" endfunction

" let g:LanguageClient_useFloatingHover = 0
" let g:LanguageClient_diagnosticsEnable = 1
" let g:LanguageClient_diagnosticsSignsMax = 200
" let g:LanguageClient_loggingLevel = 'INFO'
" let g:LanguageClient_useVirtualText = 'All'
" let g:LanguageClient_diagnosticsList = 'Location'

" }}}
"==============================================================================
" GUTENTAGS {{{
"==============================================================================
" enable gtags module
" let g:gutentags_modules = ['ctags', 'gtags_cscope']

let g:gutentags_ctags_executable=g:ctags_exe
let g:gutentags_ctags_exclude=['.git', 'node_modules', '.idea']

" Dont auto add db so we can make sure only one is present,
" since we want to add manually, dont use cache dir for longer path
let g:gutentags_auto_add_gtags_cscope = 0

" debug commands
let g:gutentags_define_advanced_commands = 1

" Get files not included in source control (only problem with this is that it
" only gets java files...should change this and maybe also try aggregating
" files from other directories, then we could have the jdk files be somewhere
" else.
" let g:gutentags_file_list_command = 'fd -t f -e java'

" generate datebases in my cache directory, prevent gtags files polluting my project
" let g:gutentags_cache_dir = expand(g:vim_dir . '/tags')

" NOTE: gutentags will identify current project root by by root markers
" (.git/.svn/.root). if your project is not in any git/svn repository,
" gutentags will not generate gtags database for it. To avoid this, you can
" create an empty .root file in your project root, and gutentags will know
" where is your project root and generate gtags database for it.
" let g:gutentags_project_root = ['.root']

" disable default keymappings
" let g:gutentags_plus_nomap = 1

" change focus to quickfix window after search (optional).
" let g:gutentags_plus_switch = 1

" noremap <silent> <leader>cs :GscopeFind s <C-R><C-W><cr>
" noremap <silent> <leader>cg :GscopeFind g <C-R><C-W><cr>
" noremap <silent> <leader>cc :GscopeFind c <C-R><C-W><cr>
" noremap <silent> <leader>ct :GscopeFind t <C-R><C-W><cr>
" noremap <silent> <leader>ce :GscopeFind e <C-R><C-W><cr>
" noremap <silent> <leader>cf :GscopeFind f <C-R>=expand("<cword>")<cr><cr>
" noremap <silent> <leader>ci :GscopeFind i <C-R>=expand("<cfile>")<cr><cr>
" noremap <silent> <leader>cd :GscopeFind d <C-R><C-W><cr>
" noremap <silent> <leader>ca :GscopeFind a <C-R><C-W><cr>
" noremap <silent> <leader>cz :GscopeFind z <C-R><C-W><cr>

" nmap <leader>cs :cs find s <C-R>=expand("<cword>")<CR><CR>
" nmap <leader>cg :cs find g <C-R>=expand("<cword>")<CR><CR>
" nmap <leader>cc :cs find c <C-R>=expand("<cword>")<CR><CR>
" nmap <leader>ct :cs find t <C-R>=expand("<cword>")<CR><CR>
" nmap <leader>ce :cs find e <C-R>=expand("<cword>")<CR><CR>
" nmap <leader>cf :cs find f <C-R>=expand("<cword>")<CR><CR>
" nmap <leader>ci :cs find i ^<C-R>=expand("<cfile>")<CR>$<CR>
" nmap <leader>cd :cs find d <C-R>=expand("<cword>")<CR><CR>

" let g:gtags_jdk_home = $JAVA_HOME
" call <SID>set_gtags_jdk_src_dir(g:gtags_jdk_home)

" }}}
"==============================================================================
" FERRET {{{
"==============================================================================
" If you want to do a global replace, you need to search for the term to add it
" to the ferret quickfix, then all instances in the quickfix will be subject to
" the replacement matching when using FerretAcks
let g:FerretMap = 0

" Search for current word
nmap <F7> <Plug>(FerretAckWord)

" Need to use <C-U> to escape visual mode and not enter search
vmap <F7> :<C-U>call <SID>ferret_vack()<CR>

function! s:ferret_vack() abort
  let l:selection = s:get_visual_selection()
  for l:char in [' ', '(', ')']
      let l:selection = escape(l:selection, l:char)
  endfor
  execute ':Ack ' . l:selection
endfunction

" https://stackoverflow.com/questions/1533565/how-to-get-visually-selected-text-in-vimscript
function! s:get_visual_selection()
  " Why is this not a built-in Vim script function?!
  let [line_start, column_start] = getpos("'<")[1:2]
  let [line_end, column_end] = getpos("'>")[1:2]
  let lines = getline(line_start, line_end)
  if len(lines) == 0
      return ''
  endif
  let lines[-1] = lines[-1][: column_end - (&selection == 'inclusive' ? 1 : 2)]
  let lines[0] = lines[0][column_start - 1:]
  return join(lines, "\n")
endfunction

" Replace instances matching term in quickfix 'F19 == S-F7'
nmap <F19> <Plug>(FerretAcks)

" }}}
"==============================================================================
" FUGITIVE {{{
"==============================================================================
" This normally opens up a split buffer, to make full screen with <c-w>o
nnoremap <leader>gs :G status -s<cr>
nnoremap <leader>gS :G status<cr>
nnoremap <leader>gl :G log --oneline<cr>
nnoremap <leader>gb :!git branch<cr>
nnoremap <leader>gD :G diff HEAD<cr>
nnoremap <leader>gd :G diff HEAD %<cr>

" }}}
"==============================================================================
" NERDTREE {{{
"==============================================================================
let g:NERDTreeWinPos = "left"
let g:NERDTreeWinSize=35

" Prevent fluff from appearing in the file drawer
let NERDTreeIgnore=[
  \ '__pycache__', '^node_modules$', '\~$', '^\.git$', '^\.DS_Store$', '^\.vim$',
  \ '^\.meta$', '^\.settings$', '^\.classpath$', '^\.project$',
  \ '^\.gradle$', '^\.idea$', '^\.metadata$', '^/bin$', '^GPATH$', '^G.*TAGS$', '^tags$'
  \]

" Show hidden files in NERDTree
let NERDTreeShowHidden=1

" Ignore the help-instructions at the top of NERDTree
let NERDTreeMinimalUI=1

" Delete the NERDTree buffer when it's the only one left
let NERDTreeAutoDeleteBuffer=1

" Close automatically if nerd tree is only buffer open
" autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif

" Dont focus Nerdtree on enter
" autocmd! VimEnter * NERDTree | wincmd w

let g:NERDTreeQuitOnOpen = 0

nnoremap yoe :NERDTreeToggle<cr>
nnoremap [oe :NERDTree<cr>
nnoremap ]oe :NERDTreeClose<cr>

" }}}
"==============================================================================
" GITGUTTER {{{
"==============================================================================
let g:gitgutter_map_keys = 0

nnoremap ]h :GitGutterNextHunk<cr>
nnoremap [h :GitGutterPrevHunk<cr>

nmap <leader>hs <Plug>(GitGutterStageHunk)
nmap <leader>hu <Plug>(GitGutterUndoHunk)
nmap <leader>hp <Plug>(GitGutterPreviewHunk)

omap ih <Plug>(GitGutterTextObjectInnerPending)
omap ah <Plug>(GitGutterTextObjectOuterPending)
xmap ih <Plug>(GitGutterTextObjectInnerVisual)
xmap ah <Plug>(GitGutterTextObjectOuterVisual)

" }}}
"==============================================================================
" TAGBAR {{{
"==============================================================================
nnoremap yot :TagbarToggle<cr>
nnoremap [ot :TagbarOpen<cr>
nnoremap ]ot :TagbarClose<cr>

" }}}
"==============================================================================
" AIRLINE {{{
"==============================================================================
if g:is_colo_dracula
  let g:airline_theme='dracula'
elseif g:is_colo_gruvbox
  let g:airline_theme='gruvbox'
elseif g:is_colo_pencil
  let g:airline_theme='pencil'
endif

let g:airline_powerline_fonts = 1
" let g:airline_symbols_ascii = 1

let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#buffer_nr_show = 1

" Disable tagbar for performance
let g:airline#extensions#tagbar#enabled = 0

if !exists('g:airline_symbols')
let g:airline_symbols = {}
endif

" let g:airline_symbols.whitespace='_'
let g:airline_symbols.whitespace=''
let g:airline_symbols.linenr = ''
let g:airline_symbols.maxlinenr = ''
let g:airline_symbols.notexists = ' D'

" let g:airline_symbols.space = "\ua0"

" powerline symbols
" https://www.nerdfonts.com/cheat-sheet
let g:airline_left_sep = ''
let g:airline_left_alt_sep = ''
let g:airline_right_sep = ''
let g:airline_right_alt_sep = ''
" let g:airline_symbols.branch = '@'
let g:airline_symbols.readonly = ''
" let g:airline_symbols.linenr = ''
" let g:airline_symbols.maxlinenr = ''
let g:airline_symbols.dirty=' ?'
" let g:airline_symbols.whitespace='/s'
" let g:airline_symbols.crypt='0x'
" let g:airline_symbols.notexists=' ?'

" let airline#extensions#ale#show_line_numbers = 0
" let g:airline#extensions#ale#warning_symbol = "\uf071 "
" let g:airline#extensions#ale#error_symbol = "\uf05e "
" let g:lightline#ale#indicator_checking = "\uf110"
" let g:lightline#ale#indicator_infos = "\uf129 "
" let g:lightline#ale#indicator_ok = "\uf00c"

let g:airline#extensions#default#section_truncate_width = {
  \ 'c': 50,
  \ }

let g:airline#extensions#tabline#fnamemod = ':t'

"Reduces the space occupied by section z
let g:airline_section_z = "%3p%% %l:%c"

" }}}
"==============================================================================
" VIM-GO {{{
"==============================================================================
" For walkthrough, use the following github repo as example:
" - https://github.com/fatih/vim-go-tutorial#quick-setup
" let g:go_def_mode='godef'
" let g:go_info_mode='guru'
let g:go_def_mode='gopls'
let g:go_info_mode='gopls'

" Disable go def mapping so we can delegate it to the coc lsp = 0
" let g:go_def_mapping_enabled = 1

" Fmt on save
let g:go_fmt_autosave = 1

" Automatically format and also rewrite your import declarations
" If it is too slow, you can use the manual :GoImports command
let g:go_fmt_command = "gofmt"

" Do not run linting on save
let g:go_metalinter_autosave = 0

" Automatically highlight matching identifiers (methods, variables...)
let g:go_auto_sameids = 1

" Automatically show info when cursor on method
" Has an issue when putting cursor over lib imports
let g:go_auto_type_info = 1

" Makes all popup buffers quickfix type buffers
let g:go_list_type = "quickfix"

let g:go_highlight_types = 1
let g:go_highlight_fields = 1
let g:go_highlight_functions = 1
let g:go_highlight_function_calls = 1
let g:go_highlight_operators = 1
let g:go_highlight_build_constraints = 1
let g:go_highlight_extra_types = 1

" Default is 'func,type'
let g:go_decls_includes = 'func'

" }}}
"==============================================================================
" FZF {{{
"==============================================================================
let g:fzf_action = {
  \ 'ctrl-s': 'split',
  \ 'ctrl-v': 'vsplit' }

let g:fzf_excluded_files = [ 'node_modules', '.gradle', '*.class', '.idea', '.git', '.settings', '.project', '.classpath', '.DS_Store', 'G*TAGS', 'tags', 'GPATH' ]

if executable('fd')
  let g:fd_formatted_excluded_files = "-E '" . join(g:fzf_excluded_files, "' -E '") . "'"
  let $FZF_DEFAULT_COMMAND="fd --type f --hidden --no-ignore-vcs --color=never " . g:fd_formatted_excluded_files
elseif executable('rg')
  let g:rg_formatted_excluded_files = "-g '!" . join(g:fzf_excluded_files, "' -g '!") . "'"
  let $FZF_DEFAULT_COMMAND="rg --files --no-ignore-vcs --hidden " . g:rg_formatted_excluded_files
endif

if g:is_mac
  let g:fzf_copy_cmd = 'pbcopy'
elseif g:is_win
  let g:fzf_copy_cmd = 'copy.exe'
else
  let g:fzf_copy_cmd = 'xclip -selection clipboard'
endif

let $FZF_DEFAULT_OPTS = '--height 50% -1 --reverse --multi --inline-info ' .
      \ '--preview="bat --color=always --style=numbers {}" ' .
      \ '--preview-window="right:hidden" ' .
      \ '--bind="F2:toggle-preview" ' .
      \ '--bind="ctrl-d:half-page-down" '.
      \ '--bind="ctrl-u:half-page-up" ' .
      \ '--bind="ctrl-a:select-all+accept" ' .
      \ '--bind="ctrl-y:execute-silent(echo {+} | ' . g:fzf_copy_cmd . ')"'

nnoremap <leader>N :Files<cR>
nnoremap <leader>n :GFiles<cr>
nnoremap <leader>b :Buffers<cr>
nnoremap <leader>E :History<cr>
nnoremap <leader>x :Maps<cr>
nnoremap <leader>X :Commands<cr>
nnoremap <leader>o :BTags<cr>
nnoremap <leader>O :Tags<cr>

" Dracula adds the CursorLine highlight to fzf
let g:fzf_colors =
  \ { 'fg':      ['fg', 'Normal'],
  \ 'bg':      ['bg', 'Normal'],
  \ 'hl':      ['fg', 'Comment'],
  \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
  \ 'hl+':     ['fg', 'Statement'],
  \ 'info':    ['fg', 'PreProc'],
  \ 'border':  ['fg', 'Ignore'],
  \ 'prompt':  ['fg', 'Conditional'],
  \ 'pointer': ['fg', 'Exception'],
  \ 'marker':  ['fg', 'Keyword'],
  \ 'spinner': ['fg', 'Label'],
  \ 'header':  ['fg', 'Comment'] }

if g:is_nvim
  " https://github.com/junegunn/fzf.vim/issues/221
  autocmd FileType fzf tnoremap <buffer> <c-j> <down>
  autocmd FileType fzf tnoremap <buffer> <c-k> <up>
endif

" Disable preview with windows since fzf.vim internally uses a bash script to
" render preview window even though I can do the same with cmd using bat
if g:is_win
  let g:fzf_preview_window = ''
endif

" Hide statusline color
autocmd! FileType fzf set laststatus=0 noshowmode noruler
  \| autocmd BufLeave <buffer> set laststatus=2 showmode ruler

" [Tags] Command to generate tags file
let g:fzf_tags_command = g:ctags_exe . ' -R --exclude=.git --exclude=node_modules --exclude=.idea'

function! s:align_lists(lists)
  let maxes = {}
  for list in a:lists
    let i = 0
    while i < len(list)
      let maxes[i] = max([get(maxes, i, 0), len(list[i])])
      let i += 1
    endwhile
  endfor
  for list in a:lists
    call map(list, "printf('%-'.maxes[v:key].'s', v:val)")
  endfor
  return a:lists
endfunction

" See what fields are exposed $ ctags --list-fields
" TODO - use external java program to parse the list and format it pretty
"      - use excmd=pattern to get the matching pattern to use also in output
function! s:btags_source()
  let lines = map(split(system(printf(
    \ g:ctags_exe . ' -f - --fields=NKaF --sort=no --excmd=number --language-force=%s %s',
    \ &filetype, expand('%:S'))), "\n"), 'split(v:val, "\t")')
  if v:shell_error
    throw 'failed to extract tags'
  endif
    return map(s:align_lists(lines), 'join(v:val, "\t")')
endfunction

function! s:btags_sink(line)
  execute split(a:line, "\t")[2]
endfunction

function! s:btags()
  try
    call fzf#run({
    \ 'source':  s:btags_source(),
    \ 'options': '+m -d "\t" --with-nth 1,4.. -n 1 --tiebreak=index',
    \ 'down':    '40%',
    \ 'sink':    function('s:btags_sink')})
  catch
    echohl WarningMsg
    echom v:exception
    echohl None
  endtry
endfunction

command! BTags call s:btags()

" Replace the default dictionary completion with fzf-based fuzzy completion
inoremap <expr> <c-x><c-k> fzf#vim#complete('cat C:\Users\asidlo\Documents\dotfiles\vim\dictionary.txt')

" }}}
"==============================================================================
" ACK {{{
"==============================================================================
if executable('rg')
  set grepformat=%f:%l:%c:%m,%f:%l:%m
  set grepprg=rg\ -S\ --vimgrep\ --no-ignore-vcs\ --no-heading\ --hidden\ -g\ !tags
  " -g !tags = ignore tags file
  let g:ackprg = 'rg -S --no-heading --no-ignore-vcs --hidden --vimgrep -g !tags'
endif

" Searches whole project, even through ignored files
nnoremap \ :Ack<space>

" }}}
"==============================================================================
" MARKDOWN {{{
"==============================================================================
let g:vim_markdown_folding_style_pythonic = 1
let g:vim_markdown_math = 1
let g:vim_markdown_strikethrough = 1
let g:vim_markdown_auto_insert_bullets = 0
let g:vim_markdown_new_list_item_indent = 0


" }}}
"==============================================================================
" COMMENTARY {{{
"==============================================================================
autocmd FileType text setlocal commentstring=#\ %s
autocmd FileType json setlocal commentstring=//\ %s

" }}}
"==============================================================================
" VIM-DEVICONS {{{
"==============================================================================
"https://github.com/ryanoasis/vim-devicons/wiki/FAQ-&-Troubleshooting#how-do-i-solve-issues-after-re-sourcing-my-vimrc
if exists("g:loaded_webdevicons")
  call webdevicons#refresh()
endif

" }}}
"==============================================================================
" GIT-MESSENGER {{{
"==============================================================================
let g:git_messenger_no_default_mappings = v:true

nmap <leader>gm <Plug>(git-messenger)
" }}}
"==============================================================================
" }}}
"==============================================================================
" COMMANDS {{{
"=============================================================================
abbreviate TF TableFormat

abbreviate PC PlugClean
abbreviate PU PlugUpdate
abbreviate PI PlugInstall

abbreviate GGP GitGutterPreviewHunk
abbreviate GGU GitGutterUndoHunk
abbreviate GGS GitGutterStageHunk

" Print the directory of the current buffer
" Helpful since :pwd will print the project root dir when vim-rooter is applied
command! Dirname :echo expand('%:p:h')
abbreviate DN Dirname
abbreviate FN file


command! SyncSyntax :syntax sync fromstart
abbreviate SS SyncSyntax

command! Dos2Linux :%s///g
abbreviate D2L Dos2Linux

" Add date -> type XDATE lowercase followed by a char will autofill the date
iab xdate <c-r>=strftime("%Y/%m/%d %H:%M:%S")<cr>
iab ldate <c-r>=strftime("%A %B %d, %Y")<cr>
cab xdate <c-r>=strftime("%Y-%m-%d")<cr>

command! -bar -nargs=1 -complete=file WriteQF
            \ call writefile([json_encode(s:qf_to_filename(getqflist({'all': 1})))], <f-args>)

command! -bar -nargs=1 -complete=file ReadQF
            \ call setqflist([], ' ', json_decode(get(readfile(<f-args>), 0, '')))

" https://www.reddit.com/r/vim/comments/9iwr41/store_quickfix_list_as_a_file_and_load_it/
function! s:qf_to_filename(qf) abort
  for i in range(len(a:qf.items))
    let d = a:qf.items[i]
    if bufexists(d.bufnr)
      let d.filename = fnamemodify(bufname(d.bufnr), ':p')
    endif
    silent! call remove(d, 'bufnr')
    let a:qf.items[i] = d
  endfor
  return a:qf
endfunction

command! -nargs=0 Scriptnames
            \ call fzf#run({'source': split(execute('scriptnames'), '\n'), 'down': '30%'})

" }}}
"==============================================================================
" FILETYPES {{{
"==============================================================================
augroup go_files
  autocmd!
  autocmd FileType go setlocal noexpandtab tabstop=4 shiftwidth=4
  autocmd FileType go nmap <leader>m :<c-u>call <SID>build_go_files()<cr>
  autocmd Filetype go command! -bang A call go#alternate#Switch(<bang>0, 'edit')
  autocmd Filetype go command! -bang AV call go#alternate#Switch(<bang>0, 'vsplit')
  autocmd Filetype go command! -bang AS call go#alternate#Switch(<bang>0, 'split')
  autocmd Filetype go command! -bang AT call go#alternate#Switch(<bang>0, 'tabe')
augroup end

" Run :GoBuild or :GoTestCompile based on the go file
function! s:build_go_files()
  let l:file = expand('%')
  if l:file =~# '^\f\+_test\.go$'
  call go#test#Test(0, 1)
  elseif l:file =~# '^\f\+\.go$'
    call go#cmd#Build(0)
  endif
endfunction

" set compiler option via :compiler gradlew
augroup java_files
  autocmd!
  autocmd FileType java nmap [[ [m
  autocmd FileType java nmap ]] ]m
  autocmd FileType java,groovy setlocal tabstop=4 shiftwidth=4 expandtab colorcolumn=120
augroup END

augroup json_files
  autocmd!
  autocmd FileType json syntax match Comment +\/\/.\+$+
augroup END

augroup xml_files
  autocmd!
  autocmd FileType xml setlocal foldmethod=indent foldlevelstart=999 foldminlines=0
augroup END

augroup markdown_files
  autocmd!
  autocmd FileType markdown setlocal textwidth=79 tabstop=2 shiftwidth=2
augroup END

augroup vim_files
  autocmd!
  autocmd FileType vim setlocal foldmethod=marker tabstop=2 shiftwidth=2
augroup END

augroup zsh_files
  autocmd!
  autocmd FileType zsh setlocal foldmethod=marker
augroup END

augroup nx_logs
  autocmd!
  autocmd BufEnter agent-service*.log,base-service*.log,gateway-service*.log,compute-service*.log,control-service*.log setlocal syntax=nxlog
augroup END

augroup LuaHighlight
  autocmd!
  autocmd TextYankPost * silent! lua require'vim.highlight'.on_yank()
augroup END
" }}}
"==============================================================================
