"==============================================================================
" Author:  Andrew Sidlo
" Updated: 2020/02/26 18:26:50
"==============================================================================
" Section: Variables {{{
"==============================================================================
let g:is_win = has('win32') || has('win64')
let g:is_linux = has('unix') && !has('macunix')
let g:is_mac = has('macunix')
let g:is_gui = has('gui_running')
let g:is_nvim = has('nvim')

" Vim directory where all settings, plugins, syntax, etc stored
" Note: expand vs glob = glob will return empty if file doesnt exist
" also, expand has a list of special variables (see :h expand)
if g:is_win
  let g:vim_dir = expand('~/vimfiles')
  let g:rc_file = expand('~/_vimrc')
else
  let g:vim_dir = expand('~/.vim')
  let g:rc_file = expand('~/.vimrc')
endif

" Disable python2, ruby, and node providers
let g:loaded_python_provider = 0
let g:loaded_ruby_provider = 0
let g:loaded_node_provider = 0

if !executable('fd')
  echoerr 'fd executable not found! Install and add to Path to perform fuzzy searching'
endif

if !executable('rg')
  echoerr 'Ripgrep executable not found! Install and add to Path to perform project searching'
endif

" Path to Python 3 interpreter (must be an absolute path), make startup
" faster. See https://neovim.io/doc/user/provider.html.
if executable('python') || executable('python3')
  if g:is_win
    let g:python3_host_prog=substitute(exepath('python'), '.exe$', '', 'g')
  elseif g:is_linux || g:is_mac
    let g:python3_host_prog=exepath('python3')
  endif
else
  echoerr 'Python 3 executable not found! You must install Python 3 and set its PATH correctly!'
endif

" }}}
"==============================================================================
" Section: Plugin Manager {{{
"==============================================================================
" Automatically download the plug.vim plugin manager vimscript
" Run :PlugInstall to install all plugins
if !g:is_win
  if empty(glob('~/.vim/autoload/plug.vim'))
    silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
          \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
    autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
  endif
endif

call plug#begin(g:vim_dir . '/plugged')

" Colorschemes
Plug 'nanotech/jellybeans.vim'
Plug 'morhetz/gruvbox'
Plug 'dracula/vim', { 'as': 'dracula' }

Plug 'godlygeek/tabular'

" Golang plugins
" Need to load before vim-polyglot in order to avoid getting errors like
" Unknown function: go#config#GoplsMatcher
" See: https://github.com/fatih/vim-go/issues/2272
" See: https://github.com/fatih/vim-go/issues/2262
Plug 'fatih/vim-go', { 'do': ':GoUpdateBinaries' }
Plug 'AndrewRadev/splitjoin.vim'

Plug 'tiagofumo/vim-nerdtree-syntax-highlight'
Plug 'scrooloose/nerdtree'
Plug 'airblade/vim-gitgutter'
Plug 'vim-airline/vim-airline'

Plug 'jmcantrell/vim-virtualenv'

Plug 'iamcco/markdown-preview.nvim', { 'do': { -> mkdp#util#install() } }
Plug 'plasticboy/vim-markdown'

Plug 'mileszs/ack.vim'
Plug 'airblade/vim-rooter'
Plug 'ryanoasis/vim-devicons'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-unimpaired'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-eunuch'
Plug 'tpope/vim-dispatch'

Plug 'jreybert/vimagit'
Plug 'rhysd/git-messenger.vim'

" Can be used to change case of word.
" Ex: gsciw (changeToCamelCase), gs_iw (snake_case), gs-iw (kabob-case)
Plug 'arthurxavierx/vim-caser'

" Uses 'gr' to replace current selection with specified register contents
" Ex: "ayiw (copies inner word to register a) -> "agriw (replaces inner word
"     with content from register 'a')
Plug 'vim-scripts/ReplaceWithRegister'

" Targets indents
" Ex: gcii (toggles comment for all adjacent inner indented lines)
Plug 'michaeljsmith/vim-indent-object'

" Show the current index count for search
Plug 'henrik/vim-indexed-search'

" Automatically clear search highlights after you move your cursor.
" Doesnt seem to work with windows for some reason
Plug 'haya14busa/is.vim'

" Handle multi-file find and replace.
Plug 'mhinz/vim-grepper'

" Completion, highlighting, and linting
Plug 'sheerun/vim-polyglot'
Plug 'neoclide/coc.nvim', {'tag': '*', 'branch': 'release'}

Plug 'dense-analysis/ale'

" Symbol / Tag Plugins
Plug 'majutsushi/tagbar'
Plug 'ludovicchabant/vim-gutentags'

" Snippets (using coc-snippets so no need for Ultisnips)
Plug 'honza/vim-snippets'
Plug 'segeljakt/vim-silicon'

" Fuzzy searching (will install if not already in path)
Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
Plug 'junegunn/fzf.vim'

Plug 'moll/vim-bbye' " optional dependency
Plug 'aymericbeaumet/vim-symlink'

call plug#end()

ab PC PlugClean
ab PU PlugUpdate
ab PI PlugInstall

" }}}
"==============================================================================
" Section: Settings {{{
"==============================================================================
let mapleader=","

syntax enable

colorscheme dracula

" Makes highlighting not an eyesore
let g:dracula_inverse = 0

set t_Co=256
set background=dark
set termguicolors

if g:is_gui
  " No toolbars, menu, or scrollbars in the GUI
  set guifont=MesloLGM\ Nerd\ Font\ Mono:h12
  set guioptions-=m " no menu
  set guioptions-=T " no toolbar
  set guioptions-=l
  set guioptions-=L
  set guioptions-=r " no scrollbar
  set guioptions-=R
endif

" See vulnerability:
" https://github.com/numirias/security/blob/master/doc/2019-06-04_ace-vim-neovim.md
set modelines=0
set nomodeline

" You can bind contents of the visual selection to system primary buffer
" (* register in vim, usually referred as «mouse» buffer) by using
if g:is_nvim
  vnoremap <LeftRelease> "*ygv
  set clipboard=unnamed
elseif g:is_mac
  set clipboard^=autoselect
else
  set clipboard=unnamed
endif

" Unset paste on InsertLeave.
autocmd InsertLeave * silent! set nopaste

" Dont insert first suggestion from autocompletions (omnicomplete)
" https://vim.fandom.com/wiki/Make_Vim_completion_popup_menu_work_just_like_in_an_IDE
set completeopt=longest,menuone
set omnifunc=syntaxcomplete#Complete

" Enable mouse support for specific modes
set mouse=a

"Enable filetype plugins
filetype plugin on
filetype indent on

" Disable autofolding
set nofoldenable

" Save local marks up to 100 files ('100) and global marks (f1)
" Remove all marks for buffer :delm!
" Remove all global marks :delm A-Z0-9
set viminfo='100,f1

" Add line numbers
set number

" Turn on relative number
set relativenumber

set cursorline

" You will have bad experience for diagnostic messages when it's default 4000.
set updatetime=100

" don't give |ins-completion-menu| messages.
set shortmess+=c

" always show signcolumns
set signcolumn=yes

" Disable line wrapping
set nowrap

" Add 80, 120 line columns
set colorcolumn=80,120

"Always show current position
set ruler

" Height of the command bar
set cmdheight=2

" Hide mode indicator in command bar, since its covered via lightline
set noshowmode

" Add a bit extra margin to the left
set foldcolumn=0

" Don't redraw while executing macros (good performance config)
set lazyredraw

" Show matching brackets when text indicator is over them
set showmatch

" How many tenths of a second to blink when matching brackets
set mat=2

" Always show the status line
set laststatus=2

" No annoying sound on errors
set noerrorbells
set novisualbell
set t_vb=
set timeoutlen=500

" Set utf8 as standard encoding and en_US as the standard language
set encoding=utf8

" Use Unix as the standard file type
set ffs=unix,dos,mac

" A buffer becomes hidden when it is abandoned
set hid

"New splits below, not above
set splitbelow

"New splits on the right, not left
set splitright

" Make merging lines smarter when using <shift-j>
if v:version > 703 || v:version == 703 && has('patch541')
  set formatoptions+=j
endif

" Set 7 lines to the cursor - when moving vertically using j/k
set so=7

" Set to auto read when a file is changed from the outside
set autoread

" Automatically saves a file when calling :make, such as is done
" in go commands and when exiting vim
set autowriteall

" Turn backup off, since most stuff is in SVN, git et.c anyway...
set nobackup
set nowb
set noswapfile

" Linebreak on 500 characters if set wrap
set lbr
set tw=500
set nowrap

" How to represent non-printable characters
" In general, don't want tabs, so have them show up as special characters
set listchars=tab:>-,trail:_,extends:>,precedes:<,nbsp:~
set showbreak=\\ "
setlocal list "turn the above on

" Configure backspace so it acts as it should act
set backspace=eol,start,indent
set whichwrap+=<,>,h,l

" For regular expressions turn magic on
set magic

" Ignore case when searching
set ignorecase

" When searching try to be smart about cases
set smartcase

" Highlight search results
set hlsearch

" Remove previous highlight, but keep in register
noh

" Makes search act like search in modern browsers
set incsearch

" Use spaces instead of tabs
set expandtab

" Be smart when using tabs ;)
set smarttab

" 1 tab == 4 spaces (tabstop)
set shiftwidth=2
set tabstop=2

set ai "Auto indent
set si "Smart indent

" When using airline with tabbuffers on, dont set this as reloading config file
" causes the tabline to disappear.
" Show tab number only if more than 1
" set stal=1

" Sets how many lines of history VIM has to remember
set history=500

" Disable the netrw history file which is otherwise added to ~/.vim/.netrwhist
let g:netrw_dirhistmax = 0

" This enables us to undo files even if you exit Vim.
" Note: this dir needs to be made prior to working
let s:undo_dir = g:vim_dir . '/undo'
if empty(glob(s:undo_dir))
  echoerr "Undo dir does not exist, create it using :Mkdir " . s:undo_dir
endif

let &undodir = s:undo_dir
set undofile

" Turn on the Wild menu
" https://stackoverflow.com/questions/9511253/how-to-effectively-use-vim-wildmenu
set wildmenu
set wildmode=longest:full,full

" Ignore compiled files
set wildignore=*.o,*~,*.pyc
set wildignore+=*/.git/*,*/.hg/*,*/.svn/*,*/.DS_Store

"}}}
"==============================================================================
" Section: Mappings {{{
"==============================================================================
" Visual linewise up and down by default (and use gj gk to go quicker)
" Move cusor by display lines when wrapping
noremap <up> gk
noremap <down> gj
noremap j gj
noremap k gk

" If you want to kill all buffers matching regex, then you need to use <C-A>
" after the regex to expand out the matches
if g:is_nvim
  " Leader q to exit terminal mode
  tnoremap <leader>q <c-\><c-n>:q<cr>

  " mappings to move out from terminal to other views
  tnoremap <c-h> <c-\><c-n><c-w>h
  tnoremap <c-j> <c-\><c-n><c-w>j
  tnoremap <c-k> <c-\><c-n><c-w>k
  tnoremap <c-l> <c-\><c-n><c-w>l

  " Note: <c-backspace> should be used for backspace, since normal bs exits insert mode
  " Also, Altc+ - should be used instead of just -
  " Open terminal in vertical, horizontal and new tab
  nnoremap <leader>tv :vsplit term://fish<cr>
  nnoremap <leader>ts :split term://fish<cr>
  nnoremap <leader>tt :e term://fish<cr>

  " always start terminal in insert mode
  autocmd BufWinEnter,WinEnter term://* startinsert
endif

" Format paragraph (selected or not) to 80 character lines.
" gqip

" Prevent selecting and pasting from overwriting what you originally copied.
xnoremap p pgvy

" Keep cursor at the bottom of the visual selection after you yank it.
vmap y ygv<esc>

" Prevent x from overriding what's in the clipboard.
noremap x "_x
noremap X "_x

" search will center on the line it's found in.
nnoremap n nzzzv
nnoremap N Nzzzv

" Act like D and C
" yank from current position till end of line
nnoremap Y y$

" Edit global todo.md
nnoremap <expr> <leader>td ':e ' . g:vim_dir . '/todo.md<cr>'

" Reload vimrc
nnoremap confr :source $MYVIMRC<cr>

" Edit vimrc
" Note: '<expr>' is required to using variable in mapping
" See: h: map-expression
nnoremap <expr> confe ':e ' . g:rc_file . '<cr>'

" Switch to last buffer
nnoremap <leader>e :e#<cr>

" save using <C-s> in every mode
" when in operator-pending or insert, takes you to normal mode
nnoremap <c-s> :write<Cr>
vnoremap <c-s> <c-c>:write<Cr>
inoremap <c-s> <esc>:write<Cr>
onoremap <c-s> <esc>:write<Cr>

" use `u` to undo, use `U` to redo, mind = blown
nnoremap U <c-r>

"https://vim.fandom.com/wiki/Fast_window_resizing_with_plus/minus_keys
"+ increases vertical buffer, - decreases
if bufwinnr(1)
  nnoremap + <c-w>+
  nnoremap _ <c-w>-
endif

" Switch CWD to the directory of the open buffer
nnoremap <leader>cd :cd %:p:h<cr>:pwd<cr>

" Print the directory of the current buffer
" Helpful since :pwd will print the project root dir when vim-rooter is applied
command! Dirname :echo expand('%:p:h')
" nnoremap <leader>dn :Dirname<cr>
" nnoremap <leader>fn :file<cr>

" Return to last edit position when opening files (You want this!)
au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif

"Go back to visual mode after indenting
vnoremap < <gv
vnoremap > >gv

" Use alt+j/k to move line down/up
" https://vim.fandom.com/wiki/Moving_lines_up_or_down
" https://vi.stackexchange.com/questions/2572/detect-os-in-vimscript
" Move a line of text using ALT+[jk] or Command+[jk] on mac
" Note: requires remapping of option/alt key in iterm term profile for macos to +esc
nnoremap <A-j> :m .+1<cr>==
nnoremap <A-k> :m .-2<cr>==
inoremap <A-j> <esc>:m .+1<cr>==gi
inoremap <A-k> <esc>:m .-2<cr>==gi
vnoremap <A-j> :m '>+1<cr>gv=gv
vnoremap <A-k> :m '<-2<cr>gv=gv

"Smart way to move between windows
nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k
nnoremap <c-h> <c-w>h
nnoremap <c-l> <c-w>l

" Move to the first/last non-blank character on this line
nnoremap H ^
nnoremap L $

" Quick Saving
nnoremap <leader>w :w<cr>

" Quick quit
nnoremap <leader>q :q<cr>

" Quick esc
inoremap jj <esc>

" Visual mode pressing * or # searches for the current selection
" Super useful! From an idea by Michael Naumann
" Could replace with visual-star-search plugin
vnoremap <silent> * :<c-u>call VisualSelection('', '')<cr>/<c-r>=@/<cr><cr>
vnoremap <silent> # :<c-u>call VisualSelection('', '')<cr>?<c-r>=@/<cr><cr>

" Clear highlighting on escape in normal mode
" https://stackoverflow.com/a/1037182
" nnoremap <esc> :noh<return><esc>
" nnoremap <esc>^[ <esc>^[
nnoremap <leader><cr> :noh<cr>

" * highlights current word without navigating to first occurance
nnoremap * :let @/='\<<c-r>=expand("<cword>")<cr>\>'<cr>:set hls<cr>

function! VisualSelection(direction, extra_filter) range
  let l:saved_reg = @"
  execute "normal! vgvy"

  let l:pattern = escape(@", "\\/.*'$^~[]")
  let l:pattern = substitute(l:pattern, "\n$", "", "")

  if a:direction == 'gv'
    call CmdLine("Ack '" . l:pattern . "' " )
  elseif a:direction == 'replace'
    call CmdLine("%s" . '/'. l:pattern . '/')
  endif

  let @/ = l:pattern
  let @" = l:saved_reg
endfunction

" Press * to search for the term under the cursor or a visual selection and
" then press a key below to replace all instances of it in the current file.
" c = confirm each
nnoremap <leader>s :%s///gc<left><left><left>

" The same as above but instead of acting on the whole file it will be
" restricted to the previously visually selected range. You can do that by
" pressing *, visually selecting the range you want it to apply to and then
" press a key below to replace all instances of it in the current selection.
xnoremap <leader>s :s///gc<left><left><left>

" Type a replacement term and press . to repeat the replacement again. Useful
" for replacing a few instances of the term (comparable to multiple cursors).
nnoremap <silent> s* :let @/='\<'.expand('<cword>').'\>'<cr>cgn
xnoremap <silent> s* "sy:let @/=@s<cr>cgn

" Map <Space> to / (search)
map <space> /
map <c-space> ?

" Vim like keys for the command line
cnoremap <c-h> <home>
cnoremap <c-l> <end>
cnoremap <c-k> <c-u>
cnoremap <c-p> <up>
cnoremap <c-n> <down>

" Add date -> type XDATE lowercase followed by a char will autofill the date
iab xdate <c-r>=strftime("%Y/%m/%d %H:%M:%S")<cr>

" Note can also use :lop / :lcl
nnoremap [ok :lopen<cr>
nnoremap ]ok :lclose<cr>

" Note can also use :cope / :ccl
nnoremap [oq :copen<cr>
nnoremap ]oq :cclose<cr>
nnoremap yoq :call ToggleQuickfix()<cr>

function! g:ToggleQuickfix()
  for winnr in range(1, winnr('$'))
    if getwinvar(winnr, '&syntax') == 'qf'
      cclose
      return
    endif
  endfor
  copen
endfunction

" }}}
"==============================================================================
" Section: Plugins {{{
"==============================================================================
" Magit {{{
"==============================================================================
let g:magit_default_fold_level = 0

" }}}
"==============================================================================
" Dispatch {{{
"==============================================================================

" }}}
"==============================================================================
" ALE {{{
"==============================================================================
" let g:ale_set_loclist = 0
" let g:ale_set_quickfix = 1

" }}}
"==============================================================================
" Vim-grepper {{{
"==============================================================================
let g:grepper={}
let g:grepper.rg = { 'grepprg': 'rg -S --no-heading --hidden --vimgrep' }
let g:grepper.tools=["rg"]

" Find all references in project
xmap <leader>/ <plug>(GrepperOperator)
nmap <leader>/ :Grepper -cword -noprompt<cr>

" Search whole project
nnoremap \ :Grepper<cr>

" After searching for text, press this mapping to do a project wide find and
" replace. It's similar to <leader>rf except this one applies to all matches
" across all files instead of just the current file.
nnoremap <leader>S
  \ :let @s='\<'.expand('<cword>').'\>'<cr>
  \ :Grepper -cword -noprompt<cr>
  \ :cfdo %s/<c-r>s//gc \| update
  \<left><left><left><left><left><left><left><left><left><left><left><left>

" The same as above except it works with a visual selection.
xmap <leader>S
    \ "sy
    \ gvgr
    \ :cfdo %s/<c-r>s//gc \| update
     \<left><left><left><left><left><left><left><left><left><left><left><left>

" }}}
"==============================================================================
" Fugitive {{{
"==============================================================================
" This normally opens up a split buffer, to make full screen with <c-w>o
nnoremap <leader>gs :Gstatus<cr>
nnoremap <leader>gl :Glog -n 50<cr>

" --paginate/-p runs the command via the terminal and captures its output
" Retains color which is nice for git branch
" Running -P/--no-pager or :Git! will output contents to a tmp file and add it
" to a split buffer which is useful for lots of output
nnoremap <leader>gb :Git --paginate branch<cr>

" }}}
"==============================================================================
" NerdTree {{{
"==============================================================================
let g:NERDTreeWinPos = "left"
let g:NERDTreeWinSize=35

" Prevent fluff from appearing in the file drawer
let NERDTreeIgnore=[
            \ '\.pyc$', '__pycache__', 'node_modules$', '\~$', '\.git$',
            \ '\.DS_Store$', '\.meta$', '\.settings', '\.classpath', '\.project',
            \ '^\.gradle$', '^\.idea$'
            \]

" Show hidden files in NERDTree
let NERDTreeShowHidden=1

" Ignore the help-instructions at the top of NERDTree
let NERDTreeMinimalUI=1

" Delete the NERDTree buffer when it's the only one left
let NERDTreeAutoDeleteBuffer=1

" Close automatically if nerd tree is only buffer open
" autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif

" Dont focus Nerdtree on enter
" autocmd! VimEnter * NERDTree | wincmd w

let g:NERDTreeQuitOnOpen = 0

nnoremap yoe :NERDTreeToggle<cr>
nnoremap [oe :NERDTree<cr>
nnoremap ]oe :NERDTreeClose<cr>

" }}}
"==============================================================================
" GitGutter {{{
"==============================================================================
let g:gitgutter_map_keys = 0

nnoremap ]h :GitGutterNextHunk<cr>
nnoremap [h :GitGutterPrevHunk<cr>

" }}}
"==============================================================================
" TagBar {{{
"==============================================================================
nnoremap yot :TagbarToggle<cr>
nnoremap [ot :TagbarOpen<cr>
nnoremap ]ot :TagbarClose<cr>

" }}}
"==============================================================================
" Airline {{{
"==============================================================================
let g:airline_theme='dracula'
let g:airline_powerline_fonts = 1

let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#buffer_nr_show = 1

" Disable tagbar for performance
let g:airline#extensions#tagbar#enabled = 0
let g:airline#extensions#coc#enabled = 1

if !exists('g:airline_symbols')
  let g:airline_symbols = {}
endif

let g:airline_symbols.space = "\ua0"

" powerline symbols
" https://www.nerdfonts.com/cheat-sheet
let g:airline_left_sep = ''
let g:airline_left_alt_sep = ''
let g:airline_right_sep = ''
let g:airline_right_alt_sep = ''
let g:airline_symbols.branch = 'שׂ'
let g:airline_symbols.readonly = ''
let g:airline_symbols.linenr = '☰'
let g:airline_symbols.maxlinenr = ''
let g:airline_symbols.dirty=' ??'

let airline#extensions#ale#show_line_numbers = 0

let g:airline#extensions#ale#warning_symbol = "\uf071 "
let g:airline#extensions#ale#error_symbol = "\uf05e "

let g:lightline#ale#indicator_checking = "\uf110"
let g:lightline#ale#indicator_infos = "\uf129 "
let g:lightline#ale#indicator_ok = "\uf00c"

" Prepend the separator to the status
function! AirlineCocStatus() abort
  let l:status = coc#status()
  if trim(l:status) != ''
    return '  ' . g:airline_left_alt_sep . ' ' . coc#status()
  endif
  return ''
endfunction

call airline#parts#define_function('coc_status', 'AirlineCocStatus')
" let g:airline_section_c = airline#section#create_right(['file', 'readonly', 'coc_status'])

let g:airline#extensions#default#section_truncate_width = {
    \ 'c': 50,
    \ }

let g:airline#extensions#tabline#fnamemod = ':t'

" }}}
"==============================================================================
" Vim-Go {{{
"==============================================================================
" For walkthrough, use the following github repo as example:
" - https://github.com/fatih/vim-go-tutorial#quick-setup
" let g:go_def_mode='godef'
" let g:go_info_mode='guru'
let g:go_def_mode='gopls'
let g:go_info_mode='gopls'

" Disable go def mapping so we can delegate it to the coc lsp = 0
let g:go_def_mapping_enabled = 0

" Fmt on save
let g:go_fmt_autosave = 1

" Automatically format and also rewrite your import declarations
" If it is too slow, you can use the manual :GoImports command
let g:go_fmt_command = "gofmt"

" Do not run linting on save
let g:go_metalinter_autosave = 0

" Automatically highlight matching identifiers (methods, variables...)
let g:go_auto_sameids = 1

" Automatically show info when cursor on method
" Has an issue when putting cursor over lib imports
let g:go_auto_type_info = 1

" Makes all popup buffers quickfix type buffers
let g:go_list_type = "quickfix"

let g:go_highlight_types = 1
let g:go_highlight_fields = 1
let g:go_highlight_functions = 1
let g:go_highlight_function_calls = 1
let g:go_highlight_operators = 1
let g:go_highlight_build_constraints = 1
let g:go_highlight_extra_types = 1

" Default is 'func,type'
let g:go_decls_includes = 'func'

" }}}
"==============================================================================
" FZF {{{
"==============================================================================
let g:fzf_action = {
  \ 'ctrl-t': 'tab split',
  \ 'ctrl-s': 'split',
  \ 'ctrl-v': 'vsplit' }

if executable('fd')
  let $FZF_DEFAULT_COMMAND="fd --type f --hidden --no-ignore-vcs --color=never -E .git -E node_modules -E .gradle -E '*.class' -E .idea -E .settings -E .project -E .classpath"
elseif executable('rg')
  let $FZF_DEFAULT_COMMAND="rg --files --no-ignore-vcs --hidden"
endif

nnoremap <leader>N :Files<cR>
nnoremap <leader>n :GFiles<cr>
nnoremap <leader>b :Buffers<cr>
nnoremap <leader>E :History<cr>
nnoremap <leader>x :Maps<cr>
nnoremap <leader>X :Commands<cr>
nnoremap <leader>o :BTags<cr>
nnoremap <leader>O :Tags<cr>

" Match color scheme
let g:fzf_colors =
  \ { 'fg':      ['fg', 'Normal'],
  \ 'bg':      ['bg', 'Normal'],
  \ 'hl':      ['fg', 'Comment'],
  \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
  \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
  \ 'gutter':  ['bg', 'Normal'],
  \ 'hl+':     ['fg', 'Statement'],
  \ 'info':    ['fg', 'PreProc'],
  \ 'border':  ['fg', 'Ignore'],
  \ 'prompt':  ['fg', 'Conditional'],
  \ 'pointer': ['fg', 'Exception'],
  \ 'marker':  ['fg', 'Keyword'],
  \ 'spinner': ['fg', 'Label'],
  \ 'header':  ['fg', 'Comment'] }

if g:is_nvim
  " https://github.com/junegunn/fzf.vim/issues/221
  autocmd FileType fzf tnoremap <buffer> <c-j> <down>
  autocmd FileType fzf tnoremap <buffer> <c-k> <up>
endif

" }}}
"==============================================================================
" Ack {{{
"==============================================================================
if executable('rg')
  set grepformat=%f:%l:%c:%m,%f:%l:%m
  set grepprg=rg\ -S\ --vimgrep\ --no-ignore-vcs\ --no-heading\ --hidden\ -g\ !tags
  " -g !tags = ignore tags file
  let g:ackprg = 'rg -S --no-heading --no-ignore-vcs --hidden --vimgrep -g !tags'
endif

" Searches whole project, even through ignored files
nnoremap <leader>\ :Ack<space>

" }}}
"==============================================================================
" Markdown {{{
"==============================================================================
let g:vim_markdown_folding_disabled = 1
let g:vim_markdown_math = 1
let g:vim_markdown_strikethrough = 1

let g:vim_markdown_auto_insert_bullets = 0
let g:vim_markdown_new_list_item_indent = 0
" let g:vim_markdown_no_default_key_mappings = 1

augroup markdown
  autocmd!
  autocmd BufNewFile,BufRead CHANGELOG.txt,README.txt set filetype=markdown
  autocmd FileType markdown set textwidth=79
augroup END

" }}}
"==============================================================================
" Commentary {{{
"==============================================================================
autocmd FileType text setlocal commentstring=#\ %s
autocmd FileType json setlocal commentstring=//\ %s

" }}}
"==============================================================================
" Vim-devicons {{{
"==============================================================================
"https://github.com/ryanoasis/vim-devicons/wiki/FAQ-&-Troubleshooting#how-do-i-solve-issues-after-re-sourcing-my-vimrc
if exists("g:loaded_webdevicons")
  call webdevicons#refresh()
endif

" }}}
"==============================================================================
" Section: Coc Mappings {{{
"==============================================================================
let g:coc_global_extensions=[
      \ 'coc-json', 'coc-eslint', 'coc-tsserver',
      \ 'coc-html', 'coc-css', 'coc-vetur', 'coc-rls',
      \ 'coc-yaml', 'coc-python', 'coc-lists', 'coc-git',
      \ 'coc-vimlsp', 'coc-xml', 'coc-snippets',
      \ 'coc-marketplace', 'coc-prettier',
      \ 'coc-java', 'coc-clangd'
      \]

if g:is_win
  let g:coc_global_extensions = add(g:coc_global_extensions, 'coc-powershell')
endif

command! -nargs=0 CocStatus echo coc#status()
ab CS CocStatus

" Close the preview window when completion is done.
autocmd! CompleteDone * if pumvisible() == 0 | pclose | endif

" Use tab for trigger completion with characters ahead and navigate.
" NOTE: Use command ':verbose imap <tab>' to make sure tab is not mapped by
" other plugin before putting this into your config.
inoremap <silent><expr> <TAB>
      \ pumvisible() ? "\<C-n>" :
      \ <SID>check_back_space() ? "\<TAB>" :
      \ coc#refresh()
inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

function! s:check_back_space() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

" Use <m-space> to trigger completion.
inoremap <silent><expr> <c-space> coc#refresh()

" Use <cr> to confirm completion, `<c-g>u` means break undo chain at current position.
" Coc only does snippet and additional edit on confirm.
inoremap <expr> <cr> pumvisible() ? "\<c-y>" : "\<c-g>u\<cr>"

if exists('*CocActionAsync')
  " Highlight symbol under cursor on CursorHold
  autocmd CursorHold * silent call CocActionAsync('highlight')
endif

" Use `[c` and `]c` to navigate diagnostics
nmap <silent> [c <Plug>(coc-diagnostic-prev)
nmap <silent> ]c <Plug>(coc-diagnostic-next)

" Use K to see documentation in a popup preview window
nnoremap <silent> K :call <SID>show_documentation()<cr>

function! s:show_documentation()
  if (index(['vim','help'], &filetype) >= 0)
    execute 'h '.expand('<cword>')
  else
    call CocAction('doHover')
  endif
endfunction

" Use `:Format` to format current buffer
command! -nargs=0 Format :call CocAction('format')
command! -nargs=? Fold :call CocAction('fold', <f-args>)
command! -nargs=0 Imports :call CocAction('runCommand', 'editor.action.organizeImport')

" Remap for format selected region
xmap <leader>F <Plug>(coc-format-selected)
nmap <leader>F :Format<cr>

nmap <leader>I :Imports<cr>

" Remap keys for gotos
nmap <silent> gd <Plug>(coc-definition)
nmap <silent> gt <Plug>(coc-type-definition)
nmap <silent> gi <Plug>(coc-implementation)
nmap <silent> gf <Plug>(coc-references)

" Rename symbol
nmap <silent> <F6> <Plug>(coc-rename)

function! SetupCommandAbbrs(from, to)
  exec 'cnoreabbrev <expr> '.a:from
        \ .' ((getcmdtype() ==# ":" && getcmdline() ==# "'.a:from.'")'
        \ .'? ("'.a:to.'") : ("'.a:from.'"))'
endfunction

" Use C to open coc config
call SetupCommandAbbrs('CC', 'CocConfig')
call SetupCommandAbbrs('CL', 'CocList')

" }}}
"==============================================================================
" }}}
"==============================================================================
" Section: Misc Functions / Commands {{{
"=============================================================================
function! Copy2Register(reg)
  let hits = []
  %s//\=len(add(hits, submatch(0))) ? submatch(0) : ''/gne
  let reg = empty(a:reg) ? '+' : a:reg
  execute 'let @'.reg.' = join(hits, "") . "\n"'
endfunction

function! CopyMatches(regex)
  " Clear the a register
  normal! qaq

  " Copy the result to the register 'A'
  execute '/' . a:regex
  call Copy2Register('A')

  " Store the result from register 'A' to the clipboard
  let @+ = trim(@a)
endfunction

" }}}
"==============================================================================
" Section: Language Specific Mappings {{{
"==============================================================================
" Go {{{
"==============================================================================
" | command         | description                                                                                         |
" | vaf             | select whole function (including comments)                                                          |
" | vif             | select function body only                                                                           |
" | dif             | delete function body                                                                                |
" | yif             | copy function body                                                                                  |
" | <c-]> or gd     | go to declaration                                                                                   |
" | <c-t>           | go back a definition                                                                                |
" | ]]              | jump to next function (accepts v]], y]], d]]...)                                                    |
" | [[              | jump to previous function                                                                           |
" | :GoWhicherrs    | Shows which types of errors can occur from error return type                                        |
" | :GoChannelPeers | Shows information about a selected channel                                                          |
" | :GoCallees      | Shows all possible targets for the current function                                                 |
" | :GoCallers      | Shows which functions call the current function and navigates to the usage, similar to GoReferrers  |
" | :GoRename       | refactor renames current identifier(only works in GOPATH)                                           |
" | :GoFreevars     | shows variables that are referenced but not defined within a given selection, helps for refactoring |
" | :GoGenerate     | runs go generate                                                                                    |
" | :GoImpl         | generates methods for a given interface                                                             |
" | :GoDeps | Dependencies of current file|
" | :GoFiles | Files in current package|
" | :GoReferrers | Find usages|
" | :GoImplements | Shows all interfaces current type/struct implements|
"
" Can also do GoImpl anywhere in file, just specify which type to attach it to
" :GoImpl b *B fmt.Stringer
" Can be custom impl also: :GoImpl github.com/asidlo/algorithms/collections.Stack

augroup go
  autocmd!

  " Show by default 4 spaces for a tab
  autocmd FileType go
    \ setlocal noexpandtab |
    \ set tabstop=4 |
    \ set shiftwidth=4 |
    \ set tw=79 |
    \ setlocal nolist

  " :GoBuild and :GoTestCompile
  autocmd FileType go nmap <leader>m :<c-u>call <SID>build_go_files()<cr>

  autocmd FileType go nmap <leader>i :GoImport<space>

  " :GoTest
  autocmd FileType go nmap <leader>T  <Plug>(go-test)
  autocmd FileType go nmap <leader>t <Plug>(go-test-func)

  " :GoRun
  if g:is_nvim
    autocmd FileType go nmap <leader>r <Plug>(go-run-split)
  else
    autocmd FileType go nmap <leader>r <Plug>(go-run)
  endif

  " :GoMetaLinter
  autocmd FileType go nmap <leader>l <Plug>(go-metalinter)

  " :GoDef but opens in a vertical split
  autocmd FileType go nmap <leader>K <Plug>(go-def-vertical)

  " :GoDef but opens in a horizontal split
  autocmd FileType go nmap <leader>k <Plug>(go-def-split)

  " :GoDecls - Show all methods in current file (Methods)
  " Think (list methods/members)
  autocmd Filetype go nmap <leader>o :GoDecls<cr>
  autocmd Filetype go nmap <leader>O :GoDeclsDir<cr>

  " :GoAlternate  commands :A, :AV, :AS and :AT
  autocmd Filetype go command! -bang A call go#alternate#Switch(<bang>0, 'edit')
  autocmd Filetype go command! -bang AV call go#alternate#Switch(<bang>0, 'vsplit')
  autocmd Filetype go command! -bang AS call go#alternate#Switch(<bang>0, 'split')
  autocmd Filetype go command! -bang AT call go#alternate#Switch(<bang>0, 'tabe')

  " Run :GoBuild or :GoTestCompile based on the go file
  function! s:build_go_files()
    let l:file = expand('%')
    if l:file =~# '^\f\+_test\.go$'
      call go#test#Test(0, 1)
    elseif l:file =~# '^\f\+\.go$'
      call go#cmd#Build(0)
    endif
  endfunction

augroup END

" }}}
"==============================================================================
" C++ {{{
"==============================================================================
autocmd FileType c,cpp
    \ set tabstop=4 |
    \ set softtabstop=4 |
    \ set shiftwidth=4 |
    \ set expandtab |
    \ set autoindent |
    \ setlocal nolist

" }}}
"==============================================================================
" Java {{{
"==============================================================================
augroup java
  autocmd!

  " Navigate functions using [ and ] instead of ]m
  autocmd FileType java nmap [[ [m
  autocmd FileType java nmap ]] ]m
  autocmd FileType java set makeprg=javac\ %
  set errorformat=%A%f:%l:\ %m,%-Z%p^,%-C.%#

  if g:is_win
    let s:gradle_exe = 'gradlew.bat'
  else
    let s:gradle_exe = 'gradlew'
  endif

  let g:java_compile_gradle_task = 'compileJava'

  " Determines whether the user is using gradle, mvn, or javac for compiling the
  " java project by utilizing rooter to check for the executable wrappers and
  " defaulting to javac if those arent present.
  function! s:CompileJava() abort
    let l:pwd = getcwd()
    exec ':Dispatch! ' . l:pwd . '/' . s:gradle_exe . ' ' . g:java_compile_gradle_task
  endfunction

  " This function will look for a main method in the filename passed as an arg
  " or the current file if not args passed and will execute it using gradle,
  " mvn, or java utilizing rooter to check for the wrapper scripts and defaulting
  " to java if none found.
  function! s:RunJavaMain() abort
    echo "TODO: implement RunJavaMain"
  endfunction

  " This function will run a linter over the entire project using
  function! s:LintJava() abort
    echo "TODO: implement LintJava"
  endfunction

  " This function will run the current test, if no args provided or all tests
  " matching a given regex using gradle, mvn, or java utilizing rooter to check
  " for the wrapper scripts and defaulting to java if none found.
  function! s:TestJava() abort
    echo "TODO: implement TestJava"
  endfunction

  autocmd FileType java nmap <leader>m :call <SID>CompileJava()<cr>

  autocmd FileType java,groovy
      \ set tabstop=4 |
      \ set softtabstop=4 |
      \ set shiftwidth=4 |
      \ set textwidth=79 |
      \ set expandtab |
      \ set autoindent |
      \ setlocal nolist

  function! CopyFullyQualifiedName()
    call CopyMatches('\(package .*\)\@<=[^;]')
    let filename = expand('%:t')
    let @+ = @+ . '.' . substitute(filename, '.java', '', '')
  endfunction

  " Get the package for the current file (Think CopyPackage)
  " Grabs all of the content between 'package' and ';' ex: 'package com.nexidia.db;'
  " https://jbodah.github.io/blog/2016/11/01/positivenegative-lookaheadlookbehind-vim/
  command! CpPkg call CopyMatches('\(package .*\)\@<=[^;]')
  command! CpImport call CopyFullyQualifiedName()
augroup END

" }}}
"==============================================================================
" Misc {{{
"==============================================================================
autocmd FileType json syntax match Comment +\/\/.\+$+
autocmd FileType vim set foldmethod=marker
autocmd BufRead,BufNewFile agent-service*.log,base-service*.log,gateway-service*.log,compute-service*.log,control-service*.log set syntax=nxlog
autocmd BufEnter *.png,*.jpg,*.gif,*.jpeg exec "silent !open ".expand("%:p")

" Open all folds = zR; Close all folds = zM
augroup XML
    autocmd!
    autocmd FileType xml setlocal foldmethod=indent foldlevelstart=999 foldminlines=0
augroup END
" }}}
"==============================================================================
" }}}
"==============================================================================
