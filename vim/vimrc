"==============================================================================
" Author:  Andrew Sidlo
" Updated: 2020/02/26 18:26:50
"==============================================================================
" Section: Variables {{{
"==============================================================================
let g:is_win = has('win32') || has('win64')
let g:is_linux = has('unix') && !has('macunix')
let g:is_nvim = has('nvim')
let g:is_gui = has('gui_running')

" Vim on windows doesn't have uname so results in error message even though we
" already know its not macos
if !g:is_nvim && g:is_win
  let g:is_mac = 0
else
  " Has some issues with vim detecting macunix/mac
  let g:is_mac = has('macunix') || substitute(system('uname -s'), '\n', '', '') == 'Darwin'
endif

" Vim directory where all settings, plugins, syntax, etc stored
" Note: expand vs glob = glob will return empty if file doesnt exist
" also, expand has a list of special variables (see :h expand)
if g:is_win
  let g:vim_dir = expand('~/vimfiles')
  let g:rc_file = expand('~/_vimrc')
else
  let g:vim_dir = expand('~/.vim')
  let g:rc_file = expand('~/.vimrc')
endif

let g:java_formatter = g:vim_dir . '/java/fmt/google-java-format.jar'
let g:java_decompiler = g:vim_dir . '/java/decompile/jd-cli.jar'

" 1 = skip, 0 = dont skip
let g:skip_go_plugin = 0
let g:skip_ctags_plugin = 0

if g:is_mac
  let g:ctags_exe = '/usr/local/opt/universal-ctags/bin/ctags'
else
  let g:ctags_exe = 'ctags'
endif

if g:is_win
  " Need to remove this var when working with non-java based repos
  " let $GTAGSLIBPATH = glob('D:\jdk8src')
  let $GTAGSTHROUGH = 'true' 
  let $GTAGSLABEL = 'pygments'
  let $GTAGSCONF = glob($GTAGS_HOME . '/share/gtags/gtags.conf')
endif

" Disable python2, ruby, and node providers
let g:loaded_python_provider = 0
let g:loaded_ruby_provider = 0
let g:loaded_node_provider = 0

let s:undo_dir = g:vim_dir . '/undo'
if empty(glob(s:undo_dir))
  echoerr "Undo dir does not exist, please create it to ensure change history: " . s:undo_dir
endif

if !executable('rg')
  echoerr 'Ripgrep executable not found! Install and add to Path to perform project searching'
endif

if !executable('fzf')
  echoerr 'fzf is required for fuzzy searching, please install fzf and add to PATH'
endif

if !executable('ctags')
  echoerr 'ctags is required for generating tags, please install ctags and add to PATH'
  let g:skip_ctags_plugin = 1
endif

if !executable('gtags')
  " https://code.google.com/archive/p/cscope-win32/downloads Or brew install
  " echoerr 'cscope executable not found! Install cscope and add to Path for static project analysis'
  echoerr 'gtags executable not found! Install gtags via gnu global package and add to Path for static project analysis'
endif

" Path to Python 3 interpreter (must be an absolute path), make startup
" faster. See https://neovim.io/doc/user/provider.html.
if executable('python') || executable('python3')
  if g:is_win
    let g:python3_host_prog=substitute(exepath('python'), '.exe$', '', 'g')
  elseif g:is_linux || g:is_mac
    let g:python3_host_prog=exepath('python3')
  endif
else
  echoerr 'Python 3 executable not found! You must install Python 3 and set its PATH correctly!'
  exit
endif

if !executable('go')
  echoerr 'Go needs to be installed in order to run the vim-go plugin'
  let g:skip_go_plugin = 1
endif

if !exists('$GOPATH')
  echoerr 'Please also set go env vars [GOPATH, GOROOT, GOBIN]'
  let g:skip_go_plugin = 1
endif

" }}}
"==============================================================================
" Section: Misc Functions / Commands {{{
"=============================================================================
" makes * and # work on visual mode too.  global function so user mappings can call it.
function! VisualStarSearchSet(cmdtype,...)
  let temp = @"
  normal! gvy
  let @/ = substitute(@", '\n', '\\n', 'g')
  let @/ = substitute(@/, '\[', '\\[', 'g')
  let @/ = substitute(@/, '\~', '\\~', 'g')
  let @" = temp
endfunction

function! Copy2Register(reg)
  let hits = []
  %s//\=len(add(hits, submatch(0))) ? submatch(0) : ''/gne
  let reg = empty(a:reg) ? '+' : a:reg
  execute 'let @'.reg.' = join(hits, "") . "\n"'
endfunction

function! CopyMatches(regex)
  " Clear the a register
  normal! qaq

  " Copy the result to the register 'A'
  execute '/' . a:regex
  call Copy2Register('A')

  " Store the result from register 'A' to the clipboard
  let @+ = trim(@a)
endfunction

" https://stackoverflow.com/questions/1533565/how-to-get-visually-selected-text-in-vimscript
function! s:get_visual_selection()
    " Why is this not a built-in Vim script function?!
    let [line_start, column_start] = getpos("'<")[1:2]
    let [line_end, column_end] = getpos("'>")[1:2]
    let lines = getline(line_start, line_end)
    if len(lines) == 0
        return ''
    endif
    let lines[-1] = lines[-1][: column_end - (&selection == 'inclusive' ? 1 : 2)]
    let lines[0] = lines[0][column_start - 1:]
    return join(lines, "\n")
endfunction

" Print the directory of the current buffer
" Helpful since :pwd will print the project root dir when vim-rooter is applied
command! Dirname :echo expand('%:p:h')
ab DN Dirname
ab FN file

command! SyncSyntax :syntax sync fromstart
ab SS SyncSyntax

command! Dos2Linux :%s///g
ab D2L Dos2Linux

" Add all TODO items to the quickfix list relative to where you opened Vim.
function! s:todo() abort
  let entries = []
  for cmd in ['git grep -niIw -e TODO -e FIXME 2> /dev/null',
            \ 'grep -rniIw -e TODO -e FIXME . 2> /dev/null']
    let lines = split(system(cmd), '\n')
    if v:shell_error != 0
      echoerr 'Error executing cmd: ' . cmd
    endif
    for line in lines
      let [fname, lno, text] = matchlist(line, '^\([^:]*\):\([^:]*\):\(.*\)')[1:3]
      call add(entries, { 'filename': fname, 'lnum': lno, 'text': text })
    endfor
    break
  endfor

  if !empty(entries)
    call setqflist(entries)
    copen
  endif
endfunction

command! Todo call s:todo()

function! s:get_libs_dir() abort
  " let l:jdk_version_dir = substitute(expand(g:gtags_jdk_home), ' ', '', 'g')
  " let l:jdk_version_dir = tolower(substitute(l:jdk_version_dir,':', '', 'g'))
  " let l:jdk_version_dir = tolower(substitute(l:jdk_version_dir,'\', '_', 'g'))
  " let l:jdk_version_dir = tolower(substitute(l:jdk_version_dir,'/', '_', 'g'))

  " if l:jdk_version_dir[0] == '_'
  "   " remove the first char if its an underscore (usually on linux)
  "   let l:jdk_version_dir = l:jdk_version_dir[1:]
  " endif

  " let $GTAGSLIBPATH = expand(g:vim_dir . '/jdk-src/' . l:jdk_version_dir) 
  " return $GTAGSLIBPATH

  return expand(getcwd() . '/jdk-src')
endfunction

" Should only create the libs dir if in a project, i.e assumes using git
" and vim-rooter
function! s:create_libs_dir() abort
  let l:libs_dir = <SID>get_libs_dir()
  if (empty(glob(l:libs_dir)))
    call mkdir(l:libs_dir, 'p')
  endif
endfunction

function! s:copy_jdk_src() abort
  let g:jdk_src = expand($JAVA_HOME . '/src.zip')
  let l:libs_dir = <SID>get_libs_dir()
  let l:libs_jdk_src = expand(l:libs_dir . '/src.zip')
  " Copy the src.zip from JAVA_HOME if not already present in libs
  if (empty(glob(l:libs_jdk_src)) && !empty(glob(g:jdk_src)))
    let l:jdk_src_zip = readfile(g:jdk_src, 'b')
    call writefile(l:jdk_src_zip, l:libs_dir . '/src.zip')
  endif
endfunction

function! s:extract_jdk_src() abort
  let l:libs_dir = <SID>get_libs_dir()
  let l:libs_jdk_src = expand(l:libs_dir . '/src.zip')
  if !executable('unzip')
    echoerr 'Unzip command not found in PATH'
    return 1
  endif

  " TODO - make async, and only exec if not already unzipped
  "      - should I namespace the jdk by version? ie unzip in jdk8_204/
  "        or should at least remove the old sdk files async as well.
  "      - Also should do custom impl of :Files command to sort the entries
  "        so that the libs in the jdk are on the bottom and when selecting
  "        files from the libs dir, the :view command is used instead of :e
  exec 'Dispatch unzip ' . l:libs_jdk_src . ' -d ' . l:libs_dir

  " Notes: Could just search in the gradle directory for the files instead of
  "        copying them locally. Could also do the same for the jvm files.
  "        Might need root perms for that though..
  " NewPlan: vim is able to directly read zip files, so just open the src.zip
  "        and open java file of choice, if we need to extract we could do that
  "        also....wonder if fd can search through zip
endfunction

" no need to call this function as it will get called internally during the
" src.zip setup extraction.
" function! s:set_gtags_jdk_src_dir(home) abort
"   let l:java_ext = ''
"   if g:is_win
"     let l:java_ext = '.exe'
"   endif

"   let l:java_home_path = a:home
"   if empty(glob(l:java_home_path))
"     if empty(glob('$'.l:java_home_path))
"       echoerr 'Arg="'.a:home.'" must be a valid JAVA_HOME path'
"       return 1
"     else
"       let l:java_home_path = expand('$'.l:java_home_path)
"     endif
"   endif

"   if empty(glob(l:java_home_path . '/bin/java' . l:java_ext))
"     echoerr 'Arg="'.a:home.'" must be a valid JAVA_HOME path'
"     return 1
"   endif

"   let g:gtags_jdk_home = l:java_home_path
"   let $GTAGSLIBPATH = <SID>get_libs_dir()
" endfunction

" function! s:init_gtags_jdk_src_dir() abort
"   let l:jdk_src_dir = <SID>get_libs_dir()
"   if !g:is_nvim
"     call chdir(l:jdk_src_dir)
"     exec ':Dispatch gtags -v -c '
"   else
"     exec ':Dispatch gtags -v -c '. l:jdk_src_dir
"   endif
" endfunction

" must pass 1 arg
" :h command-nargs
" command! -nargs=1 -complete=environment JavaGtagsJavaHome call <SID>set_gtags_jdk_src_dir(<q-args>)
" command! -nargs=0 JavaGtagsInitJdkSrc call <SID>init_gtags_jdk_src_dir()

" https://www.reddit.com/r/vim/comments/9iwr41/store_quickfix_list_as_a_file_and_load_it/
function! s:qf_to_filename(qf) abort
  for i in range(len(a:qf.items))
    let d = a:qf.items[i]
    if bufexists(d.bufnr)
      let d.filename = fnamemodify(bufname(d.bufnr), ':p')
    endif
    silent! call remove(d, 'bufnr')
    let a:qf.items[i] = d
  endfor
  return a:qf
endfunction
command! -bar -nargs=1 -complete=file WriteQF call writefile([js_encode(s:qf_to_filename(getqflist({'all': 1})))], <f-args>)
command! -bar -nargs=1 -complete=file ReadQF call setqflist([], ' ', js_decode(get(readfile(<f-args>), 0, '')))

command! -nargs=0 Scriptnames call fzf#run({'source': split(execute('scriptnames'), '\n'), 'down': '30%'})

" }}}
"==============================================================================
" Section: Plugin Manager {{{
"==============================================================================
" Automatically download the plug.vim plugin manager vimscript
" Run :PlugInstall to install all plugins
if !g:is_win
  if empty(glob('~/.vim/autoload/plug.vim'))
    silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
          \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
    autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
  endif
endif

call plug#begin(g:vim_dir . '/plugged')

" Colorschemes
Plug 'nanotech/jellybeans.vim'
Plug 'morhetz/gruvbox'
Plug 'dracula/vim', { 'as': 'dracula' }

" Tabular must come before markdown
Plug 'godlygeek/tabular'
if !g:is_win
  Plug 'iamcco/markdown-preview.nvim', { 'do': { -> mkdp#util#install() } }
endif
Plug 'plasticboy/vim-markdown'

" Golang plugins
" Need to load before vim-polyglot in order to avoid getting errors like
" Unknown function: go#config#GoplsMatcher
" See: https://github.com/fatih/vim-go/issues/2272
" See: https://github.com/fatih/vim-go/issues/2262
if !g:skip_go_plugin
  Plug 'fatih/vim-go', { 'do': ':GoUpdateBinaries' }
  Plug 'AndrewRadev/splitjoin.vim'
endif

" Plug 'rust-lang/rust.vim'
" Plug 'racer-rust/vim-racer'

Plug 'tiagofumo/vim-nerdtree-syntax-highlight'
Plug 'scrooloose/nerdtree'
Plug 'airblade/vim-gitgutter'
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
Plug 'jmcantrell/vim-virtualenv'
Plug 'wincent/ferret'
Plug 'airblade/vim-rooter'
Plug 'ryanoasis/vim-devicons'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-unimpaired'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-eunuch'
Plug 'tpope/vim-dispatch'
Plug 'rhysd/git-messenger.vim'
Plug 'jiangmiao/auto-pairs'

" Can be used to change case of word.
" Ex: gsciw (changeToCamelCase), gs_iw (snake_case), gs-iw (kabob-case)
Plug 'arthurxavierx/vim-caser'

" Uses 'gr' to replace current selection with specified register contents
" Ex: "ayiw (copies inner word to register a) -> "agriw (replaces inner word
"     with content from register 'a')
Plug 'vim-scripts/ReplaceWithRegister'

" Targets indents
" Ex: gcii (toggles comment for all adjacent inner indented lines)
Plug 'michaeljsmith/vim-indent-object'

" Completion, highlighting, and linting
Plug 'sheerun/vim-polyglot'

" Symbol / Tag Plugins
if !g:skip_ctags_plugin
  Plug 'majutsushi/tagbar'
  Plug 'ludovicchabant/vim-gutentags'
  " Plug 'skywind3000/gutentags_plus'
endif

" Snippets
Plug 'SirVer/ultisnips'
Plug 'honza/vim-snippets'
Plug 'segeljakt/vim-silicon'

" Fuzzy searching (will install if not already in path)
if g:is_mac
  Plug '/usr/local/opt/fzf'
else
  Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
endif
Plug 'junegunn/fzf.vim'

" Follow symlinks for git etc.
Plug 'moll/vim-bbye' " optional dependency
Plug 'aymericbeaumet/vim-symlink'

call plug#end()

ab PC PlugClean
ab PU PlugUpdate
ab PI PlugInstall

" }}}
"==============================================================================
" Section: Settings {{{
"==============================================================================
let mapleader=","

syntax enable

let g:is_colo_dracula = 1
let g:is_colo_gruvbox = 0
let g:is_colo_jellybeans = 0

try
  if g:is_colo_dracula
    colorscheme dracula
  elseif g:is_colo_gruvbox
    colorscheme gruvbox
  elseif g:is_colo_jellybeans
    colorscheme jellybeans
  endif
catch
  colorscheme desert
endtry

set t_Co=256
set background=dark
set termguicolors

if g:is_colo_dracula
  " Makes highlighting not an eyesore
  let g:dracula_inverse = 0

  " dracula specific highlighting
  hi Search guibg=NONE guifg=Yellow
endif

hi Search gui=underline term=underline cterm=underline

if g:is_gui
  " No toolbars, menu, or scrollbars in the GUI
  set guifont=MesloLGM\ Nerd\ Font\ Mono:h12
  set guioptions-=m " no menu
  set guioptions-=T " no toolbar
  set guioptions-=l
  set guioptions-=L
  set guioptions-=r " no scrollbar
  set guioptions-=R
endif

" See vulnerability:
" https://github.com/numirias/security/blob/master/doc/2019-06-04_ace-vim-neovim.md
set modelines=0
set nomodeline

" You can bind contents of the visual selection to system primary buffer
" (* register in vim, usually referred as «mouse» buffer) by using
if g:is_nvim
  vnoremap <LeftRelease> "*ygv
  set clipboard=unnamed
elseif g:is_mac
  set clipboard^=autoselect
else
  set clipboard=unnamed
endif

" Unset paste on InsertLeave.
autocmd InsertLeave * silent! set nopaste

" Dont insert first suggestion from autocompletions (omnicomplete)
" https://vim.fandom.com/wiki/Make_Vim_completion_popup_menu_work_just_like_in_an_IDE
set completeopt=longest,menuone
set omnifunc=syntaxcomplete#Complete

" Enable mouse support for specific modes
set mouse=a

"Enable filetype plugins
filetype plugin on
filetype indent on

" Disable autofolding
set nofoldenable

" Save local marks up to 100 files ('100) and global marks (f1)
" Remove all marks for buffer :delm!
" Remove all global marks :delm A-Z0-9
set viminfo='100,f1

" Add line numbers
set number

" Turn on relative number
set relativenumber

set cursorline

" You will have bad experience for diagnostic messages when it's default 4000.
set updatetime=100

" don't give |ins-completion-menu| messages.
set shortmess+=c

" always show signcolumns
set signcolumn=yes

" Disable line wrapping
set nowrap

" Add 80, 120 line columns
set colorcolumn=80,120

"Always show current position
set ruler

" Height of the command bar
set cmdheight=2

" Hide mode indicator in command bar, since its covered via lightline
set noshowmode

" Add a bit extra margin to the left
set foldcolumn=0

" Don't redraw while executing macros (good performance config)
set lazyredraw

" Show matching brackets when text indicator is over them
set showmatch

" How many tenths of a second to blink when matching brackets
set matchtime=2

" Always show the status line
set laststatus=2

" No annoying sound on errors
set noerrorbells
set novisualbell
set belloff=all
set t_vb=
set timeoutlen=500

" Set utf8 as standard encoding and en_US as the standard language
set encoding=utf8

" Use Unix as the standard file type
set fileformats=unix,dos,mac

" A buffer becomes hidden when it is abandoned
set hid

"New splits below, not above
set splitbelow

"New splits on the right, not left
set splitright

" Make merging lines smarter when using <shift-j>
if v:version > 703 || v:version == 703 && has('patch541')
  set formatoptions+=j
endif

" Set 7 lines to the cursor - when moving vertically using j/k
set scrolloff=0

" Set to auto read when a file is changed from the outside
set autoread

" Automatically saves a file when calling :make, such as is done
" in go commands and when exiting vim
set autowriteall

" Turn backup off, since most stuff is in SVN, git et.c anyway...
set nobackup
set nowritebackup
set noswapfile

" Linebreak on 500 characters if set wrap
set linebreak
set textwidth=119
set nowrap

" How to represent non-printable characters
" In general, don't want tabs, so have them show up as special characters
set listchars=tab:>-,trail:_,extends:>,precedes:<,nbsp:~
set showbreak=\\ "
setlocal nolist "turn chars off by default, can be toggled via yol

" Configure backspace so it acts as it should act
set backspace=eol,start,indent
set whichwrap+=<,>,h,l

" For regular expressions turn magic on
set magic

" Ignore case when searching
set ignorecase

" When searching try to be smart about cases
set smartcase

" Highlight search results
set hlsearch

" Makes search act like search in modern browsers
set incsearch

" Use spaces instead of tabs
set expandtab

" Be smart when using tabs ;)
set smarttab

" 1 tab == 4 spaces (tabstop)
set shiftwidth=4
set tabstop=4

set autoindent
set smartindent

" Sets how many lines of history VIM has to remember
set history=500

" Disable the netrw history file which is otherwise added to ~/.vim/.netrwhist
let g:netrw_dirhistmax = 0

" This enables us to undo files even if you exit Vim.
" Note: this dir needs to be made prior to working
let &undodir = s:undo_dir
set undofile

" Turn on the Wild menu
" https://stackoverflow.com/questions/9511253/how-to-effectively-use-vim-wildmenu
set wildmenu
set wildmode=longest:full,full

" Ignore compiled files
set wildignore=*.o,*~,*.pyc
set wildignore+=*/.git/*,*/.hg/*,*/.svn/*,*/.DS_Store

"}}}
"==============================================================================
" Section: Mappings {{{
"==============================================================================
" Visual linewise up and down by default (and use gj gk to go quicker)
" Move cusor by display lines when wrapping
noremap <up> gk
noremap <down> gj
noremap j gj
noremap k gk

" If you want to kill all buffers matching regex, then you need to use <C-A>
" after the regex to expand out the matches
if g:is_nvim

  " Leader q to exit terminal mode
  tnoremap <leader>q <c-\><c-n>:q<cr>
  tnoremap <leader>e <c-\><c-n>:e#<cr>
  tnoremap ]b <c-\><c-n>:bnext<cr>
  tnoremap [b <c-\><c-n>:bprevious<cr>

  " mappings to move out from terminal to other views
  tnoremap <c-h> <c-\><c-n><c-w>h
  tnoremap <c-j> <c-\><c-n><c-w>j
  tnoremap <c-k> <c-\><c-n><c-w>k
  tnoremap <c-l> <c-\><c-n><c-w>l

  " Note: <c-backspace> should be used for backspace, since normal bs exits insert mode
  " Also, Altc+ - should be used instead of just -
  " Open terminal in vertical, horizontal and new tab
  if g:is_win
    nnoremap <leader>tv :vsplit term://powershell -NoLogo -NoExit<cr>
    nnoremap <leader>ts :split term://powershell -NoLogo -NoExit<cr>
    nnoremap <leader>tt :e term://powershell -NoLogo -NoExit<cr>
  else
    nnoremap <leader>tv :vsplit term://zsh<cr>
    nnoremap <leader>ts :split term://zsh<cr>
    nnoremap <leader>tt :e term://zsh<cr>
  endif

  autocmd BufEnter term://* startinsert!
endif

" Format paragraph (selected or not) to 80 character lines.
" gqip

" Prevent selecting and pasting from overwriting what you originally copied.
xnoremap p pgvy

" Keep cursor at the bottom of the visual selection after you yank it.
vmap y ygv<esc>

" While in visual mode(double click), control-c copies to clipboard
vmap <C-C> y

" search will center on the line it's found in.
nnoremap n nzzzv
nnoremap N Nzzzv

" Act like D and C
" yank from current position till end of line
nnoremap Y y$

" Edit global todo.md
let g:notes_dir = g:vim_dir . '/notes'
if (empty(glob(g:notes_dir)))
  call mkdir(g:notes_dir)
  exec '!git clone git@github.com:asidlo/notes.git ' . g:notes_dir
endif
nnoremap <expr> <leader>td ':e ' . g:notes_dir . '/README.md<CR>' 

" Reload vimrc
nnoremap confr :source $MYVIMRC<cr>

" Edit vimrc
" Note: '<expr>' is required to using variable in mapping
" See: h: map-expression
nnoremap <expr> confe ':e ' . g:rc_file . '<cr>'

" Switch to last buffer
nnoremap <leader>e :e#<cr>

" use `u` to undo, use `U` to redo, mind = blown
nnoremap U <c-r>


" Return to last edit position when opening files (You want this!)
au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif

"Go back to visual mode after indenting
vnoremap < <gv
vnoremap > >gv

"Smart way to move between windows
nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k
nnoremap <c-h> <c-w>h
nnoremap <c-l> <c-w>l

" Move to the first/last non-blank character on this line
" H normally moves to top of the screen, L moves to bottom
" nnoremap H ^
" nnoremap L $

" Remove current highlighting
nnoremap <leader><cr> :noh<cr>

" Search for current word but dont jump to next result
nnoremap * :let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>

" Prints number of hits and num lines where hits found for last search
command! SearchHits %s///gn

" replace vim's built-in visual * and # behavior
xnoremap * :<C-u>call VisualStarSearchSet('/')<CR>/<C-R>=@/<CR><CR>
xnoremap # :<C-u>call VisualStarSearchSet('?')<CR>?<C-R>=@/<CR><CR>

" Press * to search for the term under the cursor or a visual selection and
" then press a key below to replace all instances of it in the current file.
" c = confirm each
nnoremap <leader>r :%s///gc<left><left><left>

" The same as above but instead of acting on the whole file it will be
" restricted to the previously visually selected range. You can do that by
" pressing *, visually selecting the range you want it to apply to and then
" press a key below to replace all instances of it in the current selection.
xnoremap <leader>r :s///gc<left><left><left>

" Map <Space> to / (search)
map <space> /
map <c-space> ?

" Vim like keys for the command line
cnoremap <c-h> <home>
cnoremap <c-l> <end>
cnoremap <c-k> <c-u>
cnoremap <c-p> <up>
cnoremap <c-n> <down>

" Add date -> type XDATE lowercase followed by a char will autofill the date
iab xdate <c-r>=strftime("%Y/%m/%d %H:%M:%S")<cr>

" Note can also use :lop / :lcl
nnoremap [ok :lopen<cr>
nnoremap ]ok :lclose<cr>

" Note can also use :cope / :ccl
nnoremap [oq :copen<cr>
nnoremap ]oq :cclose<cr>
nnoremap yoq :call ToggleQuickfix()<cr>

function! g:ToggleQuickfix()
  for winnr in range(1, winnr('$'))
    if getwinvar(winnr, '&syntax') == 'qf'
      cclose
      return
    endif
  endfor
  copen
endfunction

" use both cscope and ctag for 'ctrl-]', ':ta', and 'vim -t'
set cscopetag

" set if using gtags instead of cscope for generating db
set cscopeprg=gtags-cscope

" check cscope for definition of a symbol before checking ctags: set to 1
" if you want the reverse search order.
set cscopetagorder=0

" show msg when any other cscope db added
set cscopeverbose  

" add results (of find usages and references) to quickfix list instead of location list
set cscopequickfix=c-,t-,e-

" }}}
"==============================================================================
" Section: Plugins {{{
"==============================================================================
" Gutentags {{{
"==============================================================================
" enable gtags module
let g:gutentags_modules = ['ctags', 'gtags_cscope']

let g:gutentags_ctags_executable=g:ctags_exe
let g:gutentags_ctags_exclude=['.git', 'node_modules', '.idea']

" Dont auto add db so we can make sure only one is present,
" since we want to add manually, dont use cache dir for longer path
let g:gutentags_auto_add_gtags_cscope = 0

" debug commands
let g:gutentags_define_advanced_commands = 1

" Get files not included in source control (only problem with this is that it
" only gets java files...should change this and maybe also try aggregating
" files from other directories, then we could have the jdk files be somewhere
" else. 
let g:gutentags_file_list_command = 'fd -t f -e java'

" generate datebases in my cache directory, prevent gtags files polluting my project
" let g:gutentags_cache_dir = expand(g:vim_dir . '/tags')

" NOTE: gutentags will identify current project root by by root markers
" (.git/.svn/.root). if your project is not in any git/svn repository,
" gutentags will not generate gtags database for it. To avoid this, you can
" create an empty .root file in your project root, and gutentags will know
" where is your project root and generate gtags database for it.
let g:gutentags_project_root = ['.root']

" disable default keymappings
" let g:gutentags_plus_nomap = 1

" change focus to quickfix window after search (optional).
" let g:gutentags_plus_switch = 1

" noremap <silent> <leader>cs :GscopeFind s <C-R><C-W><cr>
" noremap <silent> <leader>cg :GscopeFind g <C-R><C-W><cr>
" noremap <silent> <leader>cc :GscopeFind c <C-R><C-W><cr>
" noremap <silent> <leader>ct :GscopeFind t <C-R><C-W><cr>
" noremap <silent> <leader>ce :GscopeFind e <C-R><C-W><cr>
" noremap <silent> <leader>cf :GscopeFind f <C-R>=expand("<cword>")<cr><cr>
" noremap <silent> <leader>ci :GscopeFind i <C-R>=expand("<cfile>")<cr><cr>
" noremap <silent> <leader>cd :GscopeFind d <C-R><C-W><cr>
" noremap <silent> <leader>ca :GscopeFind a <C-R><C-W><cr>
" noremap <silent> <leader>cz :GscopeFind z <C-R><C-W><cr>

nmap <leader>cs :cs find s <C-R>=expand("<cword>")<CR><CR>	
nmap <leader>cg :cs find g <C-R>=expand("<cword>")<CR><CR>	
nmap <leader>cc :cs find c <C-R>=expand("<cword>")<CR><CR>	
nmap <leader>ct :cs find t <C-R>=expand("<cword>")<CR><CR>	
nmap <leader>ce :cs find e <C-R>=expand("<cword>")<CR><CR>	
nmap <leader>cf :cs find f <C-R>=expand("<cword>")<CR><CR>	
nmap <leader>ci :cs find i ^<C-R>=expand("<cfile>")<CR>$<CR>
nmap <leader>cd :cs find d <C-R>=expand("<cword>")<CR><CR>	

" let g:gtags_jdk_home = $JAVA_HOME
" call <SID>set_gtags_jdk_src_dir(g:gtags_jdk_home)

" }}}
"==============================================================================
" Ferret {{{
"==============================================================================
" If you want to do a global replace, you need to search for the term to add it
" to the ferret quickfix, then all instances in the quickfix will be subject to
" the replacement matching when using FerretAcks

" Perform a search and add to quickfix list
nmap <leader>a <Plug>(FerretAck)

" Perform a search and add to location list
nmap <leader>l <Plug>(FerretLack)

" Search for current word
nmap <leader>s <Plug>(FerretAckWord)

" Need to use <C-U> to escape visual mode and not enter search
vmap <leader>s :<C-U>call <SID>FerretVAck()<CR>

function! s:FerretVAck() abort
  let l:selection = s:get_visual_selection()
  execute ':Ack ' . substitute(l:selection, ' ', '\\ ', 'g')
endfunction

" Replace instances matching term in quickfix
nmap <leader>R <Plug>(FerretAcks)

" }}}
"==============================================================================
" Fugitive {{{
"==============================================================================
" This normally opens up a split buffer, to make full screen with <c-w>o
nnoremap <leader>gs :Gstatus<cr>
nnoremap <leader>gl :Glog -n 50<cr>

" --paginate/-p runs the command via the terminal and captures its output
" Retains color which is nice for git branch
" Running -P/--no-pager or :Git! will output contents to a tmp file and add it
" to a split buffer which is useful for lots of output
nnoremap <leader>gb :Git --paginate branch<cr>

" }}}
"==============================================================================
" NerdTree {{{
"==============================================================================
let g:NERDTreeWinPos = "left"
let g:NERDTreeWinSize=35

" Prevent fluff from appearing in the file drawer
let NERDTreeIgnore=[
            \ '\.pyc$', '__pycache__', 'node_modules$', '\~$', '\.git$',
            \ '\.DS_Store$', '\.meta$', '\.settings', '\.classpath', '\.project',
            \ '^\.gradle$', '^\.idea$'
            \]

" Show hidden files in NERDTree
let NERDTreeShowHidden=1

" Ignore the help-instructions at the top of NERDTree
let NERDTreeMinimalUI=1

" Delete the NERDTree buffer when it's the only one left
let NERDTreeAutoDeleteBuffer=1

" Close automatically if nerd tree is only buffer open
" autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif

" Dont focus Nerdtree on enter
" autocmd! VimEnter * NERDTree | wincmd w

let g:NERDTreeQuitOnOpen = 0

nnoremap yoe :NERDTreeToggle<cr>
nnoremap [oe :NERDTree<cr>
nnoremap ]oe :NERDTreeClose<cr>

" }}}
"==============================================================================
" GitGutter {{{
"==============================================================================
let g:gitgutter_map_keys = 0

nnoremap ]h :GitGutterNextHunk<cr>
nnoremap [h :GitGutterPrevHunk<cr>

nmap <leader>hs <Plug>(GitGutterStageHunk)
nmap <leader>hu <Plug>(GitGutterUndoHunk)
nmap <leader>hp <Plug>(GitGutterPreviewHunk)

omap ih <Plug>(GitGutterTextObjectInnerPending)
omap ah <Plug>(GitGutterTextObjectOuterPending)
xmap ih <Plug>(GitGutterTextObjectInnerVisual)
xmap ah <Plug>(GitGutterTextObjectOuterVisual)

" }}}
"==============================================================================
" TagBar {{{
"==============================================================================
nnoremap yot :TagbarToggle<cr>
nnoremap [ot :TagbarOpen<cr>
nnoremap ]ot :TagbarClose<cr>

" }}}
"==============================================================================
" Airline {{{
"==============================================================================
if g:is_colo_dracula
  let g:airline_theme='dracula'
elseif g:is_colo_gruvbox
  let g:airline_theme='gruvbox'
elseif g:is_colo_jellybeans
  let g:airline_theme='jellybeans'
endif

let g:airline_powerline_fonts = 1
" let g:airline_symbols_ascii = 1

let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#buffer_nr_show = 1

" Disable tagbar for performance
let g:airline#extensions#tagbar#enabled = 0

if !exists('g:airline_symbols')
  let g:airline_symbols = {}
endif

let g:airline_symbols.whitespace='_'
let g:airline_symbols.linenr = ''
let g:airline_symbols.maxlinenr = ''
let g:airline_symbols.notexists = ' D'

" let g:airline_symbols.space = "\ua0"

" powerline symbols
" https://www.nerdfonts.com/cheat-sheet
let g:airline_left_sep = ''
let g:airline_left_alt_sep = ''
let g:airline_right_sep = ''
let g:airline_right_alt_sep = ''
" let g:airline_symbols.branch = '@'
let g:airline_symbols.readonly = ''
" let g:airline_symbols.linenr = ''
" let g:airline_symbols.maxlinenr = ''
let g:airline_symbols.dirty=' ?'
" let g:airline_symbols.whitespace='/s'
" let g:airline_symbols.crypt='0x'
" let g:airline_symbols.notexists=' ?'

" let airline#extensions#ale#show_line_numbers = 0
" let g:airline#extensions#ale#warning_symbol = "\uf071 "
" let g:airline#extensions#ale#error_symbol = "\uf05e "
" let g:lightline#ale#indicator_checking = "\uf110"
" let g:lightline#ale#indicator_infos = "\uf129 "
" let g:lightline#ale#indicator_ok = "\uf00c"

let g:airline#extensions#default#section_truncate_width = {
    \ 'c': 50,
    \ }

let g:airline#extensions#tabline#fnamemod = ':t'

" }}}
"==============================================================================
" Vim-Go {{{
"==============================================================================
" For walkthrough, use the following github repo as example:
" - https://github.com/fatih/vim-go-tutorial#quick-setup
" let g:go_def_mode='godef'
" let g:go_info_mode='guru'
let g:go_def_mode='gopls'
let g:go_info_mode='gopls'

" Disable go def mapping so we can delegate it to the coc lsp = 0
" let g:go_def_mapping_enabled = 1

" Fmt on save
let g:go_fmt_autosave = 1

" Automatically format and also rewrite your import declarations
" If it is too slow, you can use the manual :GoImports command
let g:go_fmt_command = "gofmt"

" Do not run linting on save
let g:go_metalinter_autosave = 0

" Automatically highlight matching identifiers (methods, variables...)
let g:go_auto_sameids = 1

" Automatically show info when cursor on method
" Has an issue when putting cursor over lib imports
let g:go_auto_type_info = 1

" Makes all popup buffers quickfix type buffers
let g:go_list_type = "quickfix"

let g:go_highlight_types = 1
let g:go_highlight_fields = 1
let g:go_highlight_functions = 1
let g:go_highlight_function_calls = 1
let g:go_highlight_operators = 1
let g:go_highlight_build_constraints = 1
let g:go_highlight_extra_types = 1

" Default is 'func,type'
let g:go_decls_includes = 'func'

" }}}
"==============================================================================
" FZF {{{
"==============================================================================
let g:fzf_action = {
  \ 'ctrl-s': 'split',
  \ 'ctrl-v': 'vsplit' }

if executable('fd')
  let $FZF_DEFAULT_COMMAND="fd --type f --hidden --no-ignore-vcs --color=never -E .git -E node_modules -E .gradle -E *.class -E .idea -E .settings -E .project -E .classpath"
elseif executable('rg')
  let $FZF_DEFAULT_COMMAND="rg --files --no-ignore-vcs --hidden -g !tags -g !.git -g !.gradle -g !*.class -g !node_modules -g !.idea -g !.settings -g !.project -g !.classpath"
endif

nnoremap <leader>N :Files<cR>
nnoremap <leader>n :GFiles<cr>
nnoremap <leader>b :Buffers<cr>
nnoremap <leader>E :History<cr>
nnoremap <leader>x :Maps<cr>
nnoremap <leader>X :Commands<cr>
nnoremap <leader>o :BTags<cr>
nnoremap <leader>O :Tags<cr>

" Match color scheme for gruvbox since term has dracula colors tweaked and
" defined in $FZF_DEFAULT_OPTS
if g:is_colo_gruvbox
  let g:fzf_colors =
    \ { 'fg':      ['fg', 'Normal'],
    \ 'bg':      ['bg', 'Normal'],
    \ 'hl':      ['fg', 'Comment'],
    \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
    \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
    \ 'gutter':  ['bg', 'Normal'],
    \ 'hl+':     ['fg', 'Statement'],
    \ 'info':    ['fg', 'PreProc'],
    \ 'border':  ['fg', 'Ignore'],
    \ 'prompt':  ['fg', 'Conditional'],
    \ 'pointer': ['fg', 'Exception'],
    \ 'marker':  ['fg', 'Keyword'],
    \ 'spinner': ['fg', 'Label'],
    \ 'header':  ['fg', 'Comment'] }
else
  let g:fzf_colors =
    \ {  'fg':      ['fg', 'Normal'],
    \    'bg':      ['bg', 'Normal'],
    \ }
endif

if g:is_nvim
  " https://github.com/junegunn/fzf.vim/issues/221
  autocmd FileType fzf tnoremap <buffer> <c-j> <down>
  autocmd FileType fzf tnoremap <buffer> <c-k> <up>
endif

" Disable preview with windows since fzf.vim internally uses a bash script to 
" render preview window even though I can do the same with cmd using bat
if g:is_win
  let g:fzf_preview_window = ''
endif

" [Tags] Command to generate tags file
let g:fzf_tags_command = g:ctags_exe . ' -R --exclude=.git --exclude=node_modules --exclude=.idea'

function! s:align_lists(lists)
  let maxes = {}
  for list in a:lists
    let i = 0
    while i < len(list)
      let maxes[i] = max([get(maxes, i, 0), len(list[i])])
      let i += 1
    endwhile
  endfor
  for list in a:lists
    call map(list, "printf('%-'.maxes[v:key].'s', v:val)")
  endfor
  return a:lists
endfunction

" See what fields are exposed $ ctags --list-fields
" TODO - use external java program to parse the list and format it pretty
"      - use excmd=pattern to get the matching pattern to use also in output
function! s:btags_source()
  let lines = map(split(system(printf(
    \ g:ctags_exe . ' -f - --fields=NKaF --sort=no --excmd=number --language-force=%s %s',
    \ &filetype, expand('%:S'))), "\n"), 'split(v:val, "\t")')
  if v:shell_error
    throw 'failed to extract tags'
  endif
  return map(s:align_lists(lines), 'join(v:val, "\t")')
endfunction

function! s:btags_sink(line)
  execute split(a:line, "\t")[2]
endfunction

function! s:btags()
  try
    call fzf#run({
    \ 'source':  s:btags_source(),
    \ 'options': '+m -d "\t" --with-nth 1,4.. -n 1 --tiebreak=index',
    \ 'down':    '40%',
    \ 'sink':    function('s:btags_sink')})
  catch
    echohl WarningMsg
    echom v:exception
    echohl None
  endtry
endfunction

command! BTags call s:btags()

" Replace the default dictionary completion with fzf-based fuzzy completion
inoremap <expr> <c-x><c-k> fzf#vim#complete('cat /usr/share/dict/words')

" }}}
"==============================================================================
" Ack {{{
"==============================================================================
if executable('rg')
  set grepformat=%f:%l:%c:%m,%f:%l:%m
  set grepprg=rg\ -S\ --vimgrep\ --no-ignore-vcs\ --no-heading\ --hidden\ -g\ !tags
  " -g !tags = ignore tags file
  let g:ackprg = 'rg -S --no-heading --no-ignore-vcs --hidden --vimgrep -g !tags'
endif

" Searches whole project, even through ignored files
nnoremap \ :Ack<space>

" }}}
"==============================================================================
" Markdown {{{
"==============================================================================
let g:vim_markdown_folding_style_pythonic = 1
let g:vim_markdown_math = 1
let g:vim_markdown_strikethrough = 1
let g:vim_markdown_auto_insert_bullets = 0
let g:vim_markdown_new_list_item_indent = 0


" }}}
"==============================================================================
" Commentary {{{
"==============================================================================
autocmd FileType text setlocal commentstring=#\ %s
autocmd FileType json setlocal commentstring=//\ %s

" }}}
"==============================================================================
" Vim-devicons {{{
"==============================================================================
"https://github.com/ryanoasis/vim-devicons/wiki/FAQ-&-Troubleshooting#how-do-i-solve-issues-after-re-sourcing-my-vimrc
if exists("g:loaded_webdevicons")
  call webdevicons#refresh()
endif

" }}}
"==============================================================================
" }}}
"==============================================================================
" Section: Language Specific Mappings {{{
"==============================================================================
" Go {{{
"==============================================================================
" | command         | description                                                                                         |
" | vaf             | select whole function (including comments)                                                          |
" | vif             | select function body only                                                                           |
" | dif             | delete function body                                                                                |
" | yif             | copy function body                                                                                  |
" | <c-]> or gd     | go to declaration                                                                                   |
" | <c-t>           | go back a definition                                                                                |
" | ]]              | jump to next function (accepts v]], y]], d]]...)                                                    |
" | [[              | jump to previous function                                                                           |
" | :GoWhicherrs    | Shows which types of errors can occur from error return type                                        |
" | :GoChannelPeers | Shows information about a selected channel                                                          |
" | :GoCallees      | Shows all possible targets for the current function                                                 |
" | :GoCallers      | Shows which functions call the current function and navigates to the usage, similar to GoReferrers  |
" | :GoRename       | refactor renames current identifier(only works in GOPATH)                                           |
" | :GoFreevars     | shows variables that are referenced but not defined within a given selection, helps for refactoring |
" | :GoGenerate     | runs go generate                                                                                    |
" | :GoImpl         | generates methods for a given interface                                                             |
" | :GoDeps | Dependencies of current file|
" | :GoFiles | Files in current package|
" | :GoReferrers | Find usages|
" | :GoImplements | Shows all interfaces current type/struct implements|
"
" Can also do GoImpl anywhere in file, just specify which type to attach it to
" :GoImpl b *B fmt.Stringer
" Can be custom impl also: :GoImpl github.com/asidlo/algorithms/collections.Stack

augroup go
  autocmd!

  " Show by default 4 spaces for a tab
  autocmd FileType go
    \ setlocal noexpandtab |
    \ set tabstop=4 |
    \ set shiftwidth=4 |
    \ set textwidth=79

  " :GoBuild and :GoTestCompile
  autocmd FileType go nmap <leader>m :<c-u>call <SID>build_go_files()<cr>

  " :GoAlternate  commands :A, :AV, :AS and :AT
  autocmd Filetype go command! -bang A call go#alternate#Switch(<bang>0, 'edit')
  autocmd Filetype go command! -bang AV call go#alternate#Switch(<bang>0, 'vsplit')
  autocmd Filetype go command! -bang AS call go#alternate#Switch(<bang>0, 'split')
  autocmd Filetype go command! -bang AT call go#alternate#Switch(<bang>0, 'tabe')

  " Run :GoBuild or :GoTestCompile based on the go file
  function! s:build_go_files()
    let l:file = expand('%')
    if l:file =~# '^\f\+_test\.go$'
      call go#test#Test(0, 1)
    elseif l:file =~# '^\f\+\.go$'
      call go#cmd#Build(0)
    endif
  endfunction

augroup END

" }}}
"==============================================================================
" Java {{{
"==============================================================================
augroup java
  autocmd!

  " autocmd FileType java let $GTAGSLABEL = ''

  autocmd FileType java nmap [[ [m
  autocmd FileType java nmap ]] ]m

  " || com.amazon.oa.CriticalRoutersTest > testArticulationPoints FAILED
  " src/main/java/com/amazon/oa/NumberOfClusters.java|24 col 24 error| ';' expected
  autocmd FileType java,groovy set makeprg=gradlew
  " autocmd FileType java,groovy set errorformat=
  "     \%E[ant:scalac]\ %f:%l:\ error:\ %m,
  "     \%W[ant:scalac]\ %f:%l:\ warning:\ %m,
  "     \%E%.%#:compile%\\w%#Java%f:%l:\ error:\ %m,%-Z%p^,%-C%.%#,
  "     \%W%.%#:compile%\\w%#Java%f:%l:\ warning:\ %m,%-Z%p^,%-C%.%#,
  "     \%E%f:%l:\ error:\ %m,%-Z%p^,%-C%.%#,
  "     \%W%f:%l:\ warning:\ %m,%-Z%p^,%-C%.%#,
  "     \%E%f:\ %\\d%\\+:\ %m\ @\ line\ %l\\,\ column\ %c.,%-C%.%#,%Z%p^,
  "     \%E%>%f:\ %\\d%\\+:\ %m,%C\ @\ line\ %l\\,\ column\ %c.,%-C%.%#,%Z%p^,
  "     \%-G%.%#

  autocmd FileType java,groovy
      \ set tabstop=4 |
      \ set softtabstop=4 |
      \ set shiftwidth=4 |
      \ set textwidth=119 |
      \ set expandtab

  command! -range JavaFmt <line1>,<line2>call <SID>JavaFmtRange()
  command! JavaImports execute 'Dispatch! java -jar ' . g:java_formatter . ' -a -i --fix-imports-only %:p'

  function! s:JavaFmtRange() range abort
    if a:firstline == a:lastline
      echom 'Formatting file:' . expand('%:p')
      execute 'Dispatch! java -jar ' . g:java_formatter  . ' -a -i --skip-sorting-imports --skip-removing-unused-imports %:p'
    else
      echom 'Formatting lines: ' . a:firstline . '-' . a:lastline
      execute 'Dispatch! java -jar ' . g:java_formatter . ' -a -i --skip-sorting-imports --skip-removing-unused-imports --lines=' . a:firstline . ':' . a:lastline . ' %:p'
    endif
  endfunction

  xmap <leader>F :JavaFmt<CR>
  nmap <leader>F :JavaFmt<CR>
  nmap <leader>I :JavaImports<CR>

  command! JavaCollectLibs 
        \ call <SID>create_libs_dir() |
        \ call <SID>copy_jdk_src() |
        \ call <SID>extract_jdk_src()

 " call fzf#run({ 'source': 'unzip -l src.zip', 'down': '40%' }) 

augroup END

" }}}
"==============================================================================
" Misc {{{
"==============================================================================
autocmd FileType json syntax match Comment +\/\/.\+$+
autocmd FileType vim set foldmethod=marker tabstop=2 shiftwidth=2
autocmd BufEnter *zshrc set foldmethod=marker
autocmd BufEnter,BufNewFile agent-service*.log,base-service*.log,gateway-service*.log,compute-service*.log,control-service*.log set syntax=nxlog
autocmd BufEnter *.png,*.jpg,*.gif,*.jpeg exec "silent !open ".expand("%:p")

" Open all folds = zR; Close all folds = zM
" Close all folds = zM; Open all folds = zR
augroup XML
    autocmd!
    autocmd FileType xml setlocal foldmethod=indent foldlevelstart=999 foldminlines=0
augroup END

augroup Markdown
  autocmd!
  autocmd FileType markdown set textwidth=79
augroup END

augroup Txt
  autocmd!
  autocmd BufNewFile,BufEnter *.txt set textwidth=79 syntax=markdown
augroup END

" }}}
"==============================================================================
" }}}
"==============================================================================
